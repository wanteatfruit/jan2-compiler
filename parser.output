Terminals unused in grammar

   TOKEN_ARRAY
   TOKEN_BOOLEAN
   TOKEN_CHARACTER
   TOKEN_FLOAT
   TOKEN_FUNCTION
   TOKEN_INTEGER
   TOKEN_STRING
   TOKEN_VOID
   TOKEN_CHARACTER_LITERAL
   TOKEN_STRING_LITERAL
   TOKEN_ELSE
   TOKEN_FALSE
   TOKEN_FOR
   TOKEN_IF
   TOKEN_PRINT
   TOKEN_RETURN
   TOKEN_TRUE
   TOKEN_WHILE
   TOKEN_AUTO
   TOKEN_IDENTIFIER
   TOKEN_L_BRACKET
   TOKEN_R_BRACKET
   TOKEN_L_BRACE
   TOKEN_R_BRACE
   TOKEN_POSTINC
   TOKEN_POSTDEC
   TOKEN_NEG
   TOKEN_NOT
   TOKEN_EXP
   TOKEN_MOD
   TOKEN_LESS
   TOKEN_LE
   TOKEN_GE
   TOKEN_GREATER
   TOKEN_EQUAL
   TOKEN_NEQUAL
   TOKEN_AND
   TOKEN_OR
   TOKEN_ASSIGN
   TOKEN_COLON
   TOKEN_COMMA
   TOKEN_BACKSLASH
   TOKEN_C_COMMENT
   TOKEN_CPP_COMMENT
   TOKEN_ERROR
   TOKEN_EOF


Grammar

    0 $accept: program $end

    1 program: expr TOKEN_SEMICOLON

    2 expr: expr TOKEN_ADD term
    3     | expr TOKEN_SUB term
    4     | term

    5 term: term TOKEN_MUL factor
    6     | term TOKEN_DIV factor
    7     | factor

    8 factor: TOKEN_SUB factor
    9       | TOKEN_ADD factor
   10       | TOKEN_L_PAREN expr TOKEN_R_PAREN
   11       | TOKEN_INTEGER_LITERAL
   12       | TOKEN_FLOAT_LITERAL


Terminals, with rules where they appear

$end (0) 0
error (256)
TOKEN_ARRAY (258)
TOKEN_BOOLEAN (259)
TOKEN_CHARACTER (260)
TOKEN_FLOAT (261)
TOKEN_FUNCTION (262)
TOKEN_INTEGER (263)
TOKEN_STRING (264)
TOKEN_VOID (265)
TOKEN_INTEGER_LITERAL (266) 11
TOKEN_CHARACTER_LITERAL (267)
TOKEN_STRING_LITERAL (268)
TOKEN_FLOAT_LITERAL (269) 12
TOKEN_ELSE (270)
TOKEN_FALSE (271)
TOKEN_FOR (272)
TOKEN_IF (273)
TOKEN_PRINT (274)
TOKEN_RETURN (275)
TOKEN_TRUE (276)
TOKEN_WHILE (277)
TOKEN_AUTO (278)
TOKEN_IDENTIFIER (279)
TOKEN_L_PAREN (280) 10
TOKEN_R_PAREN (281) 10
TOKEN_L_BRACKET (282)
TOKEN_R_BRACKET (283)
TOKEN_L_BRACE (284)
TOKEN_R_BRACE (285)
TOKEN_POSTINC (286)
TOKEN_POSTDEC (287)
TOKEN_NEG (288)
TOKEN_NOT (289)
TOKEN_EXP (290)
TOKEN_MUL (291) 5
TOKEN_DIV (292) 6
TOKEN_MOD (293)
TOKEN_ADD (294) 2 9
TOKEN_SUB (295) 3 8
TOKEN_LESS (296)
TOKEN_LE (297)
TOKEN_GE (298)
TOKEN_GREATER (299)
TOKEN_EQUAL (300)
TOKEN_NEQUAL (301)
TOKEN_AND (302)
TOKEN_OR (303)
TOKEN_ASSIGN (304)
TOKEN_SEMICOLON (305) 1
TOKEN_COLON (306)
TOKEN_COMMA (307)
TOKEN_BACKSLASH (308)
TOKEN_C_COMMENT (309)
TOKEN_CPP_COMMENT (310)
TOKEN_ERROR (311)
TOKEN_EOF (312)


Nonterminals, with rules where they appear

$accept (58)
    on left: 0
program (59)
    on left: 1, on right: 0
expr (60)
    on left: 2 3 4, on right: 1 2 3 10
term (61)
    on left: 5 6 7, on right: 2 3 4 5 6
factor (62)
    on left: 8 9 10 11 12, on right: 5 6 7 8 9


State 0

    0 $accept: . program $end

    TOKEN_INTEGER_LITERAL  shift, and go to state 1
    TOKEN_FLOAT_LITERAL    shift, and go to state 2
    TOKEN_L_PAREN          shift, and go to state 3
    TOKEN_ADD              shift, and go to state 4
    TOKEN_SUB              shift, and go to state 5

    program  go to state 6
    expr     go to state 7
    term     go to state 8
    factor   go to state 9


State 1

   11 factor: TOKEN_INTEGER_LITERAL .

    $default  reduce using rule 11 (factor)


State 2

   12 factor: TOKEN_FLOAT_LITERAL .

    $default  reduce using rule 12 (factor)


State 3

   10 factor: TOKEN_L_PAREN . expr TOKEN_R_PAREN

    TOKEN_INTEGER_LITERAL  shift, and go to state 1
    TOKEN_FLOAT_LITERAL    shift, and go to state 2
    TOKEN_L_PAREN          shift, and go to state 3
    TOKEN_ADD              shift, and go to state 4
    TOKEN_SUB              shift, and go to state 5

    expr    go to state 10
    term    go to state 8
    factor  go to state 9


State 4

    9 factor: TOKEN_ADD . factor

    TOKEN_INTEGER_LITERAL  shift, and go to state 1
    TOKEN_FLOAT_LITERAL    shift, and go to state 2
    TOKEN_L_PAREN          shift, and go to state 3
    TOKEN_ADD              shift, and go to state 4
    TOKEN_SUB              shift, and go to state 5

    factor  go to state 11


State 5

    8 factor: TOKEN_SUB . factor

    TOKEN_INTEGER_LITERAL  shift, and go to state 1
    TOKEN_FLOAT_LITERAL    shift, and go to state 2
    TOKEN_L_PAREN          shift, and go to state 3
    TOKEN_ADD              shift, and go to state 4
    TOKEN_SUB              shift, and go to state 5

    factor  go to state 12


State 6

    0 $accept: program . $end

    $end  shift, and go to state 13


State 7

    1 program: expr . TOKEN_SEMICOLON
    2 expr: expr . TOKEN_ADD term
    3     | expr . TOKEN_SUB term

    TOKEN_ADD        shift, and go to state 14
    TOKEN_SUB        shift, and go to state 15
    TOKEN_SEMICOLON  shift, and go to state 16


State 8

    4 expr: term .
    5 term: term . TOKEN_MUL factor
    6     | term . TOKEN_DIV factor

    TOKEN_MUL  shift, and go to state 17
    TOKEN_DIV  shift, and go to state 18

    $default  reduce using rule 4 (expr)


State 9

    7 term: factor .

    $default  reduce using rule 7 (term)


State 10

    2 expr: expr . TOKEN_ADD term
    3     | expr . TOKEN_SUB term
   10 factor: TOKEN_L_PAREN expr . TOKEN_R_PAREN

    TOKEN_R_PAREN  shift, and go to state 19
    TOKEN_ADD      shift, and go to state 14
    TOKEN_SUB      shift, and go to state 15


State 11

    9 factor: TOKEN_ADD factor .

    $default  reduce using rule 9 (factor)


State 12

    8 factor: TOKEN_SUB factor .

    $default  reduce using rule 8 (factor)


State 13

    0 $accept: program $end .

    $default  accept


State 14

    2 expr: expr TOKEN_ADD . term

    TOKEN_INTEGER_LITERAL  shift, and go to state 1
    TOKEN_FLOAT_LITERAL    shift, and go to state 2
    TOKEN_L_PAREN          shift, and go to state 3
    TOKEN_ADD              shift, and go to state 4
    TOKEN_SUB              shift, and go to state 5

    term    go to state 20
    factor  go to state 9


State 15

    3 expr: expr TOKEN_SUB . term

    TOKEN_INTEGER_LITERAL  shift, and go to state 1
    TOKEN_FLOAT_LITERAL    shift, and go to state 2
    TOKEN_L_PAREN          shift, and go to state 3
    TOKEN_ADD              shift, and go to state 4
    TOKEN_SUB              shift, and go to state 5

    term    go to state 21
    factor  go to state 9


State 16

    1 program: expr TOKEN_SEMICOLON .

    $default  reduce using rule 1 (program)


State 17

    5 term: term TOKEN_MUL . factor

    TOKEN_INTEGER_LITERAL  shift, and go to state 1
    TOKEN_FLOAT_LITERAL    shift, and go to state 2
    TOKEN_L_PAREN          shift, and go to state 3
    TOKEN_ADD              shift, and go to state 4
    TOKEN_SUB              shift, and go to state 5

    factor  go to state 22


State 18

    6 term: term TOKEN_DIV . factor

    TOKEN_INTEGER_LITERAL  shift, and go to state 1
    TOKEN_FLOAT_LITERAL    shift, and go to state 2
    TOKEN_L_PAREN          shift, and go to state 3
    TOKEN_ADD              shift, and go to state 4
    TOKEN_SUB              shift, and go to state 5

    factor  go to state 23


State 19

   10 factor: TOKEN_L_PAREN expr TOKEN_R_PAREN .

    $default  reduce using rule 10 (factor)


State 20

    2 expr: expr TOKEN_ADD term .
    5 term: term . TOKEN_MUL factor
    6     | term . TOKEN_DIV factor

    TOKEN_MUL  shift, and go to state 17
    TOKEN_DIV  shift, and go to state 18

    $default  reduce using rule 2 (expr)


State 21

    3 expr: expr TOKEN_SUB term .
    5 term: term . TOKEN_MUL factor
    6     | term . TOKEN_DIV factor

    TOKEN_MUL  shift, and go to state 17
    TOKEN_DIV  shift, and go to state 18

    $default  reduce using rule 3 (expr)


State 22

    5 term: term TOKEN_MUL factor .

    $default  reduce using rule 5 (term)


State 23

    6 term: term TOKEN_DIV factor .

    $default  reduce using rule 6 (term)
