=====STUDENT TESTS=====
====Good Tests====
===[good0.bminor Input]===

===[good0.bminor Output]===
Success!

TOKEN_EOF 
Parse successful


return code: 0


===[good1.bminor Input]===
/* declaration */

x: integer;
y: integer = 123;
f: float = 45.67;
b: boolean = false;
c: char    = 'q';
s: string  = "hello bminor\n";
a: array [5] integer;
a: array [5] integer = {1, 2, 3, 4, 5};
square: function float ( x: integer );
square: function float ();
x: integer = a[1];  // comment
//comment
//jj
===[good1.bminor Output]===
Success!

TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER y
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 123
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER f
TOKEN_COLON :
TOKEN_FLOAT float
TOKEN_ASSIGN =
269 45.67
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER b
TOKEN_COLON :
TOKEN_BOOLEAN boolean
TOKEN_ASSIGN =
TOKEN_FALSE false
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER c
TOKEN_COLON :
TOKEN_CHARACTER char
TOKEN_ASSIGN =
TOKEN_CHARACTER_LITERAL 'q'
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER s
TOKEN_COLON :
TOKEN_STRING string
TOKEN_ASSIGN =
TOKEN_STRING_LITERAL hello bminor

TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER a
TOKEN_COLON :
TOKEN_ARRAY array
TOKEN_L_BRACKET [
TOKEN_INTEGER_LITERAL 5
TOKEN_R_BRACKET ]
TOKEN_INTEGER integer
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER a
TOKEN_COLON :
TOKEN_ARRAY array
TOKEN_L_BRACKET [
TOKEN_INTEGER_LITERAL 5
TOKEN_R_BRACKET ]
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_INTEGER_LITERAL 1
TOKEN_COMMA ,
TOKEN_INTEGER_LITERAL 2
TOKEN_COMMA ,
TOKEN_INTEGER_LITERAL 3
TOKEN_COMMA ,
TOKEN_INTEGER_LITERAL 4
TOKEN_COMMA ,
TOKEN_INTEGER_LITERAL 5
TOKEN_R_BRACE }
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER square
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_FLOAT float
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER square
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_FLOAT float
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_IDENTIFIER a
TOKEN_L_BRACKET [
TOKEN_INTEGER_LITERAL 1
TOKEN_R_BRACKET ]
TOKEN_SEMICOLON ;
TOKEN_CPP_COMMENT // comment
TOKEN_CPP_COMMENT //comment
TOKEN_CPP_COMMENT //jj
TOKEN_EOF 
Parse successful


return code: 0


===[good10.bminor Input]===
// test print statements
str:string = "this is a string";
str2:string;
x:integer;
main: function void () = {
	print;
	print "bot allowed";
	print x, y, "hello", true, false;
	print str, " str ", x, str2; 
}
===[good10.bminor Output]===
Success!

TOKEN_CPP_COMMENT // test print statements
TOKEN_IDENTIFIER str
TOKEN_COLON :
TOKEN_STRING string
TOKEN_ASSIGN =
TOKEN_STRING_LITERAL this is a string
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER str2
TOKEN_COLON :
TOKEN_STRING string
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER main
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_PRINT print
TOKEN_SEMICOLON ;
TOKEN_PRINT print
TOKEN_STRING_LITERAL bot allowed
TOKEN_SEMICOLON ;
TOKEN_PRINT print
TOKEN_IDENTIFIER x
TOKEN_COMMA ,
TOKEN_IDENTIFIER y
TOKEN_COMMA ,
TOKEN_STRING_LITERAL hello
TOKEN_COMMA ,
TOKEN_TRUE true
TOKEN_COMMA ,
TOKEN_FALSE false
TOKEN_SEMICOLON ;
TOKEN_PRINT print
TOKEN_IDENTIFIER str
TOKEN_COMMA ,
TOKEN_STRING_LITERAL  str 
TOKEN_COMMA ,
TOKEN_IDENTIFIER x
TOKEN_COMMA ,
TOKEN_IDENTIFIER str2
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_EOF 
Parse successful


return code: 0


===[good11.bminor Input]===
//test expressions inside of array indexes
arr:array [5] integer = {0,1,2,3,4};

main:function void() =
{
	x:integer = 5;
	y:integer = 3;
	arr[x - y] = 4;
	arr[y + x * 3] = arr[2+ x^2 - 1];
} 
===[good11.bminor Output]===
Success!

TOKEN_CPP_COMMENT //test expressions inside of array indexes
TOKEN_IDENTIFIER arr
TOKEN_COLON :
TOKEN_ARRAY array
TOKEN_L_BRACKET [
TOKEN_INTEGER_LITERAL 5
TOKEN_R_BRACKET ]
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_INTEGER_LITERAL 0
TOKEN_COMMA ,
TOKEN_INTEGER_LITERAL 1
TOKEN_COMMA ,
TOKEN_INTEGER_LITERAL 2
TOKEN_COMMA ,
TOKEN_INTEGER_LITERAL 3
TOKEN_COMMA ,
TOKEN_INTEGER_LITERAL 4
TOKEN_R_BRACE }
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER main
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 5
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER y
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 3
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER arr
TOKEN_L_BRACKET [
TOKEN_IDENTIFIER x
TOKEN_SUB -
TOKEN_IDENTIFIER y
TOKEN_R_BRACKET ]
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 4
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER arr
TOKEN_L_BRACKET [
TOKEN_IDENTIFIER y
TOKEN_ADD +
TOKEN_IDENTIFIER x
TOKEN_MUL *
TOKEN_INTEGER_LITERAL 3
TOKEN_R_BRACKET ]
TOKEN_ASSIGN =
TOKEN_IDENTIFIER arr
TOKEN_L_BRACKET [
TOKEN_INTEGER_LITERAL 2
TOKEN_ADD +
TOKEN_IDENTIFIER x
TOKEN_EXP ^
TOKEN_INTEGER_LITERAL 2
TOKEN_SUB -
TOKEN_INTEGER_LITERAL 1
TOKEN_R_BRACKET ]
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_EOF 
Parse successful


return code: 0


===[good12.bminor Input]===
// test types of literals
x:integer = 5;
c:char = 'A';
str:string = "hello";
iarr: array [4] integer = {1,2,3,4};
carr:array [4] char = {'a', 'b', 'c', 'd'};
barr:array [4] boolean = {true, false, true, true};
iaar: array [4] array [4] integer = {iarr, iarr, iarr, iarr};
===[good12.bminor Output]===
Success!

TOKEN_CPP_COMMENT // test types of literals
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 5
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER c
TOKEN_COLON :
TOKEN_CHARACTER char
TOKEN_ASSIGN =
TOKEN_CHARACTER_LITERAL 'A'
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER str
TOKEN_COLON :
TOKEN_STRING string
TOKEN_ASSIGN =
TOKEN_STRING_LITERAL hello
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER iarr
TOKEN_COLON :
TOKEN_ARRAY array
TOKEN_L_BRACKET [
TOKEN_INTEGER_LITERAL 4
TOKEN_R_BRACKET ]
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_INTEGER_LITERAL 1
TOKEN_COMMA ,
TOKEN_INTEGER_LITERAL 2
TOKEN_COMMA ,
TOKEN_INTEGER_LITERAL 3
TOKEN_COMMA ,
TOKEN_INTEGER_LITERAL 4
TOKEN_R_BRACE }
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER carr
TOKEN_COLON :
TOKEN_ARRAY array
TOKEN_L_BRACKET [
TOKEN_INTEGER_LITERAL 4
TOKEN_R_BRACKET ]
TOKEN_CHARACTER char
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_CHARACTER_LITERAL 'a'
TOKEN_COMMA ,
TOKEN_CHARACTER_LITERAL 'b'
TOKEN_COMMA ,
TOKEN_CHARACTER_LITERAL 'c'
TOKEN_COMMA ,
TOKEN_CHARACTER_LITERAL 'd'
TOKEN_R_BRACE }
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER barr
TOKEN_COLON :
TOKEN_ARRAY array
TOKEN_L_BRACKET [
TOKEN_INTEGER_LITERAL 4
TOKEN_R_BRACKET ]
TOKEN_BOOLEAN boolean
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_TRUE true
TOKEN_COMMA ,
TOKEN_FALSE false
TOKEN_COMMA ,
TOKEN_TRUE true
TOKEN_COMMA ,
TOKEN_TRUE true
TOKEN_R_BRACE }
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER iaar
TOKEN_COLON :
TOKEN_ARRAY array
TOKEN_L_BRACKET [
TOKEN_INTEGER_LITERAL 4
TOKEN_R_BRACKET ]
TOKEN_ARRAY array
TOKEN_L_BRACKET [
TOKEN_INTEGER_LITERAL 4
TOKEN_R_BRACKET ]
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_IDENTIFIER iarr
TOKEN_COMMA ,
TOKEN_IDENTIFIER iarr
TOKEN_COMMA ,
TOKEN_IDENTIFIER iarr
TOKEN_COMMA ,
TOKEN_IDENTIFIER iarr
TOKEN_R_BRACE }
TOKEN_SEMICOLON ;
TOKEN_EOF 
Parse successful


return code: 0


===[good13.bminor Input]===
// test function calls
func1: function integer (x:integer, y:char) =
{
	print x;
	return 1;
}
func2: function integer (y:char) =
{
	print x;
	return 2;
}
func3: function integer (x:integer, y:char, z:string)=
{
	print z;
	return 4;
}

main: function void ()=
{
	x:integer = 4;
	y:char = 'c';
	z:string = "hello";
	func2('c');
	func2(y);
	func1(42, y);
	func1(x, 'c');
	func3(4, y, z);
}
===[good13.bminor Output]===
Success!

TOKEN_CPP_COMMENT // test function calls
TOKEN_IDENTIFIER func1
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_INTEGER integer
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_COMMA ,
TOKEN_IDENTIFIER y
TOKEN_COLON :
TOKEN_CHARACTER char
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_PRINT print
TOKEN_IDENTIFIER x
TOKEN_SEMICOLON ;
TOKEN_RETURN return
TOKEN_INTEGER_LITERAL 1
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_IDENTIFIER func2
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_INTEGER integer
TOKEN_L_PAREN (
TOKEN_IDENTIFIER y
TOKEN_COLON :
TOKEN_CHARACTER char
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_PRINT print
TOKEN_IDENTIFIER x
TOKEN_SEMICOLON ;
TOKEN_RETURN return
TOKEN_INTEGER_LITERAL 2
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_IDENTIFIER func3
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_INTEGER integer
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_COMMA ,
TOKEN_IDENTIFIER y
TOKEN_COLON :
TOKEN_CHARACTER char
TOKEN_COMMA ,
TOKEN_IDENTIFIER z
TOKEN_COLON :
TOKEN_STRING string
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_PRINT print
TOKEN_IDENTIFIER z
TOKEN_SEMICOLON ;
TOKEN_RETURN return
TOKEN_INTEGER_LITERAL 4
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_IDENTIFIER main
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 4
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER y
TOKEN_COLON :
TOKEN_CHARACTER char
TOKEN_ASSIGN =
TOKEN_CHARACTER_LITERAL 'c'
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER z
TOKEN_COLON :
TOKEN_STRING string
TOKEN_ASSIGN =
TOKEN_STRING_LITERAL hello
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER func2
TOKEN_L_PAREN (
TOKEN_CHARACTER_LITERAL 'c'
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER func2
TOKEN_L_PAREN (
TOKEN_IDENTIFIER y
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER func1
TOKEN_L_PAREN (
TOKEN_INTEGER_LITERAL 42
TOKEN_COMMA ,
TOKEN_IDENTIFIER y
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER func1
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_COMMA ,
TOKEN_CHARACTER_LITERAL 'c'
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER func3
TOKEN_L_PAREN (
TOKEN_INTEGER_LITERAL 4
TOKEN_COMMA ,
TOKEN_IDENTIFIER y
TOKEN_COMMA ,
TOKEN_IDENTIFIER z
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_EOF 
Parse successful


return code: 0


===[good14.bminor Input]===
/*
This program displays a square bouncing around on the screen.
Click to reset the square in a new place.
It makes use of the (included) C gfx library and the standard C library,
and exercises, loops, comparisons, and logical operators.
*/

/* These are the functions in the gfx library. */
gfx_open: function void ( width: integer, height: integer, title:string );
gfx_point: function void ( x: integer, y: integer );
gfx_line: function void ( x1:integer, y1:integer, x2:integer, y2:integer );
gfx_color: function void ( red:integer, green: integer, blue:integer );
gfx_clear: function void ();
gfx_clear_color: function void ( red:integer, green: integer, blue:integer );
gfx_wait: function char ();
gfx_xpos: function integer ();
gfx_ypos: function integer ();
gfx_xsize: function integer ();
gfx_ysize: function integer ();
gfx_event_waiting: function boolean ();
gfx_flush: function integer ();

/* These functions come from the C standard library. */

usleep: function void ( usecs: integer );
rand: function integer();

draw_box: function void ( x: integer, y:integer, size: integer ) =
{
	gfx_color(255,255,255);
	gfx_line(x,y,x+size,y);
	gfx_line(x+size,y,x+size,y+size);
	gfx_line(x+size,y+size,x,y+size);
	gfx_line(x,y+size,x,y);
}

/*
Note that the precision multiplier indicates fixed-point
match to keep track of sub-pixel position and velocity for the box.
*/

main: function integer () =
{
	precision: integer = 100;

	xsize: integer = 500; // pixels
	ysize: integer = 500; // pixels 

	x: integer = precision * xsize / 2;
	y: integer = precision * ysize / 2;

	vx: integer = precision * 3;
	vy: integer = precision * -5 ;

	deltat: integer = 100;

	gfx_open(xsize,ysize,"Bounce!");

	for(;;) {
		print "x: ", x, " y: ", y, " vx: ", vx, " vy: ", vy, "\n";

		if(gfx_event_waiting()) {
			c: char;
			c = gfx_wait();
			if(c=='q') return 0;
			x = gfx_xpos()*precision;
			y = gfx_ypos()*precision;
			vx = 5*precision;
		}

		vy = vy + 1 * precision;

		if(x<0 && vx<0) {
			vx = -9*vx/10;
		}	

		if(x>(xsize*precision) && vx>0) {
			vx = -9*vx/10;
		}

		if(y>(ysize*precision) && vy>0) {
			vy = -9*vy/10;
		}

		x = x + vx*deltat/precision;
		y = y + vy*deltat/precision;

		gfx_clear();
		draw_box(x/precision,y/precision,25);
		gfx_flush();

		usleep(deltat*precision);
	}
}
===[good14.bminor Output]===
Success!

TOKEN_IDENTIFIER gfx_open
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_IDENTIFIER width
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_COMMA ,
TOKEN_IDENTIFIER height
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_COMMA ,
TOKEN_IDENTIFIER title
TOKEN_COLON :
TOKEN_STRING string
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER gfx_point
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_COMMA ,
TOKEN_IDENTIFIER y
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER gfx_line
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x1
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_COMMA ,
TOKEN_IDENTIFIER y1
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_COMMA ,
TOKEN_IDENTIFIER x2
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_COMMA ,
TOKEN_IDENTIFIER y2
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER gfx_color
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_IDENTIFIER red
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_COMMA ,
TOKEN_IDENTIFIER green
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_COMMA ,
TOKEN_IDENTIFIER blue
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER gfx_clear
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER gfx_clear_color
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_IDENTIFIER red
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_COMMA ,
TOKEN_IDENTIFIER green
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_COMMA ,
TOKEN_IDENTIFIER blue
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER gfx_wait
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_CHARACTER char
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER gfx_xpos
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_INTEGER integer
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER gfx_ypos
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_INTEGER integer
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER gfx_xsize
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_INTEGER integer
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER gfx_ysize
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_INTEGER integer
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER gfx_event_waiting
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_BOOLEAN boolean
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER gfx_flush
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_INTEGER integer
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER usleep
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_IDENTIFIER usecs
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER rand
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_INTEGER integer
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER draw_box
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_COMMA ,
TOKEN_IDENTIFIER y
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_COMMA ,
TOKEN_IDENTIFIER size
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_IDENTIFIER gfx_color
TOKEN_L_PAREN (
TOKEN_INTEGER_LITERAL 255
TOKEN_COMMA ,
TOKEN_INTEGER_LITERAL 255
TOKEN_COMMA ,
TOKEN_INTEGER_LITERAL 255
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER gfx_line
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_COMMA ,
TOKEN_IDENTIFIER y
TOKEN_COMMA ,
TOKEN_IDENTIFIER x
TOKEN_ADD +
TOKEN_IDENTIFIER size
TOKEN_COMMA ,
TOKEN_IDENTIFIER y
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER gfx_line
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_ADD +
TOKEN_IDENTIFIER size
TOKEN_COMMA ,
TOKEN_IDENTIFIER y
TOKEN_COMMA ,
TOKEN_IDENTIFIER x
TOKEN_ADD +
TOKEN_IDENTIFIER size
TOKEN_COMMA ,
TOKEN_IDENTIFIER y
TOKEN_ADD +
TOKEN_IDENTIFIER size
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER gfx_line
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_ADD +
TOKEN_IDENTIFIER size
TOKEN_COMMA ,
TOKEN_IDENTIFIER y
TOKEN_ADD +
TOKEN_IDENTIFIER size
TOKEN_COMMA ,
TOKEN_IDENTIFIER x
TOKEN_COMMA ,
TOKEN_IDENTIFIER y
TOKEN_ADD +
TOKEN_IDENTIFIER size
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER gfx_line
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_COMMA ,
TOKEN_IDENTIFIER y
TOKEN_ADD +
TOKEN_IDENTIFIER size
TOKEN_COMMA ,
TOKEN_IDENTIFIER x
TOKEN_COMMA ,
TOKEN_IDENTIFIER y
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_IDENTIFIER main
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_INTEGER integer
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_IDENTIFIER precision
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 100
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER xsize
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 500
TOKEN_SEMICOLON ;
TOKEN_CPP_COMMENT // pixels
TOKEN_IDENTIFIER ysize
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 500
TOKEN_SEMICOLON ;
TOKEN_CPP_COMMENT // pixels 
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_IDENTIFIER precision
TOKEN_MUL *
TOKEN_IDENTIFIER xsize
TOKEN_DIV /
TOKEN_INTEGER_LITERAL 2
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER y
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_IDENTIFIER precision
TOKEN_MUL *
TOKEN_IDENTIFIER ysize
TOKEN_DIV /
TOKEN_INTEGER_LITERAL 2
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER vx
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_IDENTIFIER precision
TOKEN_MUL *
TOKEN_INTEGER_LITERAL 3
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER vy
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_IDENTIFIER precision
TOKEN_MUL *
TOKEN_SUB -
TOKEN_INTEGER_LITERAL 5
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER deltat
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 100
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER gfx_open
TOKEN_L_PAREN (
TOKEN_IDENTIFIER xsize
TOKEN_COMMA ,
TOKEN_IDENTIFIER ysize
TOKEN_COMMA ,
TOKEN_STRING_LITERAL Bounce!
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_FOR for
TOKEN_L_PAREN (
TOKEN_SEMICOLON ;
TOKEN_SEMICOLON ;
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_PRINT print
TOKEN_STRING_LITERAL x: 
TOKEN_COMMA ,
TOKEN_IDENTIFIER x
TOKEN_COMMA ,
TOKEN_STRING_LITERAL  y: 
TOKEN_COMMA ,
TOKEN_IDENTIFIER y
TOKEN_COMMA ,
TOKEN_STRING_LITERAL  vx: 
TOKEN_COMMA ,
TOKEN_IDENTIFIER vx
TOKEN_COMMA ,
TOKEN_STRING_LITERAL  vy: 
TOKEN_COMMA ,
TOKEN_IDENTIFIER vy
TOKEN_COMMA ,
TOKEN_STRING_LITERAL 

TOKEN_SEMICOLON ;
TOKEN_IF if
TOKEN_L_PAREN (
TOKEN_IDENTIFIER gfx_event_waiting
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_IDENTIFIER c
TOKEN_COLON :
TOKEN_CHARACTER char
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER c
TOKEN_ASSIGN =
TOKEN_IDENTIFIER gfx_wait
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_IF if
TOKEN_L_PAREN (
TOKEN_IDENTIFIER c
TOKEN_EQUAL ==
TOKEN_CHARACTER_LITERAL 'q'
TOKEN_R_PAREN )
TOKEN_RETURN return
TOKEN_INTEGER_LITERAL 0
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER x
TOKEN_ASSIGN =
TOKEN_IDENTIFIER gfx_xpos
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_MUL *
TOKEN_IDENTIFIER precision
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER y
TOKEN_ASSIGN =
TOKEN_IDENTIFIER gfx_ypos
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_MUL *
TOKEN_IDENTIFIER precision
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER vx
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 5
TOKEN_MUL *
TOKEN_IDENTIFIER precision
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_IDENTIFIER vy
TOKEN_ASSIGN =
TOKEN_IDENTIFIER vy
TOKEN_ADD +
TOKEN_INTEGER_LITERAL 1
TOKEN_MUL *
TOKEN_IDENTIFIER precision
TOKEN_SEMICOLON ;
TOKEN_IF if
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_LESS <
TOKEN_INTEGER_LITERAL 0
TOKEN_AND &&
TOKEN_IDENTIFIER vx
TOKEN_LESS <
TOKEN_INTEGER_LITERAL 0
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_IDENTIFIER vx
TOKEN_ASSIGN =
TOKEN_SUB -
TOKEN_INTEGER_LITERAL 9
TOKEN_MUL *
TOKEN_IDENTIFIER vx
TOKEN_DIV /
TOKEN_INTEGER_LITERAL 10
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_IF if
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_GREATER >
TOKEN_L_PAREN (
TOKEN_IDENTIFIER xsize
TOKEN_MUL *
TOKEN_IDENTIFIER precision
TOKEN_R_PAREN )
TOKEN_AND &&
TOKEN_IDENTIFIER vx
TOKEN_GREATER >
TOKEN_INTEGER_LITERAL 0
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_IDENTIFIER vx
TOKEN_ASSIGN =
TOKEN_SUB -
TOKEN_INTEGER_LITERAL 9
TOKEN_MUL *
TOKEN_IDENTIFIER vx
TOKEN_DIV /
TOKEN_INTEGER_LITERAL 10
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_IF if
TOKEN_L_PAREN (
TOKEN_IDENTIFIER y
TOKEN_GREATER >
TOKEN_L_PAREN (
TOKEN_IDENTIFIER ysize
TOKEN_MUL *
TOKEN_IDENTIFIER precision
TOKEN_R_PAREN )
TOKEN_AND &&
TOKEN_IDENTIFIER vy
TOKEN_GREATER >
TOKEN_INTEGER_LITERAL 0
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_IDENTIFIER vy
TOKEN_ASSIGN =
TOKEN_SUB -
TOKEN_INTEGER_LITERAL 9
TOKEN_MUL *
TOKEN_IDENTIFIER vy
TOKEN_DIV /
TOKEN_INTEGER_LITERAL 10
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_IDENTIFIER x
TOKEN_ASSIGN =
TOKEN_IDENTIFIER x
TOKEN_ADD +
TOKEN_IDENTIFIER vx
TOKEN_MUL *
TOKEN_IDENTIFIER deltat
TOKEN_DIV /
TOKEN_IDENTIFIER precision
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER y
TOKEN_ASSIGN =
TOKEN_IDENTIFIER y
TOKEN_ADD +
TOKEN_IDENTIFIER vy
TOKEN_MUL *
TOKEN_IDENTIFIER deltat
TOKEN_DIV /
TOKEN_IDENTIFIER precision
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER gfx_clear
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER draw_box
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_DIV /
TOKEN_IDENTIFIER precision
TOKEN_COMMA ,
TOKEN_IDENTIFIER y
TOKEN_DIV /
TOKEN_IDENTIFIER precision
TOKEN_COMMA ,
TOKEN_INTEGER_LITERAL 25
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER gfx_flush
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER usleep
TOKEN_L_PAREN (
TOKEN_IDENTIFIER deltat
TOKEN_MUL *
TOKEN_IDENTIFIER precision
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_R_BRACE }
TOKEN_EOF 
Parse successful


return code: 0


===[good15.bminor Input]===
//empty func block

f: function void () = {
  
}

// empty return
f: function void () = {
    return;
}

//empty stmt block
if(true){
  
}
===[good15.bminor Output]===
Success!

TOKEN_CPP_COMMENT //empty func block
TOKEN_IDENTIFIER f
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_R_BRACE }
TOKEN_CPP_COMMENT // empty return
TOKEN_IDENTIFIER f
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_RETURN return
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_CPP_COMMENT //empty stmt block
TOKEN_IF if
TOKEN_L_PAREN (
TOKEN_TRUE true
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_R_BRACE }
TOKEN_EOF 
Parse successful


return code: 0


===[good16.bminor Input]===
a: array[3] array[1] integer = {{1}, {2}, {3}};
===[good16.bminor Output]===
Success!

TOKEN_IDENTIFIER a
TOKEN_COLON :
TOKEN_ARRAY array
TOKEN_L_BRACKET [
TOKEN_INTEGER_LITERAL 3
TOKEN_R_BRACKET ]
TOKEN_ARRAY array
TOKEN_L_BRACKET [
TOKEN_INTEGER_LITERAL 1
TOKEN_R_BRACKET ]
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_L_BRACE {
TOKEN_INTEGER_LITERAL 1
TOKEN_R_BRACE }
TOKEN_COMMA ,
TOKEN_L_BRACE {
TOKEN_INTEGER_LITERAL 2
TOKEN_R_BRACE }
TOKEN_COMMA ,
TOKEN_L_BRACE {
TOKEN_INTEGER_LITERAL 3
TOKEN_R_BRACE }
TOKEN_R_BRACE }
TOKEN_SEMICOLON ;
TOKEN_EOF 
Parse successful


return code: 0


===[good17.bminor Input]===
//list of empty things
return;
print;
f: function void () = {

}

if(true) {

} else {

}

for(;;) {

}

f();
===[good17.bminor Output]===
Success!

TOKEN_CPP_COMMENT //list of empty things
TOKEN_RETURN return
TOKEN_SEMICOLON ;
TOKEN_PRINT print
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER f
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_R_BRACE }
TOKEN_IF if
TOKEN_L_PAREN (
TOKEN_TRUE true
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_R_BRACE }
TOKEN_ELSE else
TOKEN_L_BRACE {
TOKEN_R_BRACE }
TOKEN_FOR for
TOKEN_L_PAREN (
TOKEN_SEMICOLON ;
TOKEN_SEMICOLON ;
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_R_BRACE }
TOKEN_IDENTIFIER f
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_EOF 
Parse successful


return code: 0


===[good2.bminor Input]===
/* basic expressions */

if( temp>100 ) {
    print "It's really hot!\n";
} else if( temp>70 ) {
    print "It's pretty warm.\n";
} else {
    print "It's not too bad.\n";
}

return (f-32)*5/9;
y = m*x + b;
for( i=0; i<100; i++ ) {
    print i;
}

for(;;){
    print "forever";
}


===[good2.bminor Output]===
Success!

TOKEN_IF if
TOKEN_L_PAREN (
TOKEN_IDENTIFIER temp
TOKEN_GREATER >
TOKEN_INTEGER_LITERAL 100
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_PRINT print
TOKEN_STRING_LITERAL It's really hot!

TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_ELSE else
TOKEN_IF if
TOKEN_L_PAREN (
TOKEN_IDENTIFIER temp
TOKEN_GREATER >
TOKEN_INTEGER_LITERAL 70
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_PRINT print
TOKEN_STRING_LITERAL It's pretty warm.

TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_ELSE else
TOKEN_L_BRACE {
TOKEN_PRINT print
TOKEN_STRING_LITERAL It's not too bad.

TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_RETURN return
TOKEN_L_PAREN (
TOKEN_IDENTIFIER f
TOKEN_SUB -
TOKEN_INTEGER_LITERAL 32
TOKEN_R_PAREN )
TOKEN_MUL *
TOKEN_INTEGER_LITERAL 5
TOKEN_DIV /
TOKEN_INTEGER_LITERAL 9
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER y
TOKEN_ASSIGN =
TOKEN_IDENTIFIER m
TOKEN_MUL *
TOKEN_IDENTIFIER x
TOKEN_ADD +
TOKEN_IDENTIFIER b
TOKEN_SEMICOLON ;
TOKEN_FOR for
TOKEN_L_PAREN (
TOKEN_IDENTIFIER i
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 0
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER i
TOKEN_LESS <
TOKEN_INTEGER_LITERAL 100
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER i
TOKEN_POSTINC ++
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_PRINT print
TOKEN_IDENTIFIER i
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_FOR for
TOKEN_L_PAREN (
TOKEN_SEMICOLON ;
TOKEN_SEMICOLON ;
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_PRINT print
TOKEN_STRING_LITERAL forever
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_EOF 
Parse successful


return code: 0


===[good3.bminor Input]===
// variables in and out of fxns
x:integer = 5;
y:integer;
z:char = 'A';
fxn: function void () =
{
	x:integer;
	y:integer = 16;
	w:boolean = true;
	q:boolean;
}
===[good3.bminor Output]===
Success!

TOKEN_CPP_COMMENT // variables in and out of fxns
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 5
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER y
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER z
TOKEN_COLON :
TOKEN_CHARACTER char
TOKEN_ASSIGN =
TOKEN_CHARACTER_LITERAL 'A'
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER fxn
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER y
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 16
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER w
TOKEN_COLON :
TOKEN_BOOLEAN boolean
TOKEN_ASSIGN =
TOKEN_TRUE true
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER q
TOKEN_COLON :
TOKEN_BOOLEAN boolean
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_EOF 
Parse successful


return code: 0


===[good4.bminor Input]===
// produces correct precedence of operations

main: function void () = {
	x:integer = 5;
	y:integer = 4;
	if(true || false && true)
	{
		x = 6;
		
	}
    if(!((4*x^5 + 4) - 4 >= 1))
	{
		x = 6;
		
	}
    x:integer = 5;
	y:integer = 4;
	z:boolean  = true || -(4*x^5) + (4 - 4) >= 16 - 6 * 3 + x && y^2 == 16;
}

===[good4.bminor Output]===
Success!

TOKEN_CPP_COMMENT // produces correct precedence of operations
TOKEN_IDENTIFIER main
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 5
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER y
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 4
TOKEN_SEMICOLON ;
TOKEN_IF if
TOKEN_L_PAREN (
TOKEN_TRUE true
TOKEN_OR ||
TOKEN_FALSE false
TOKEN_AND &&
TOKEN_TRUE true
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_IDENTIFIER x
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 6
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_IF if
TOKEN_L_PAREN (
TOKEN_NOT !
TOKEN_L_PAREN (
TOKEN_L_PAREN (
TOKEN_INTEGER_LITERAL 4
TOKEN_MUL *
TOKEN_IDENTIFIER x
TOKEN_EXP ^
TOKEN_INTEGER_LITERAL 5
TOKEN_ADD +
TOKEN_INTEGER_LITERAL 4
TOKEN_R_PAREN )
TOKEN_SUB -
TOKEN_INTEGER_LITERAL 4
TOKEN_GE >=
TOKEN_INTEGER_LITERAL 1
TOKEN_R_PAREN )
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_IDENTIFIER x
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 6
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 5
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER y
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 4
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER z
TOKEN_COLON :
TOKEN_BOOLEAN boolean
TOKEN_ASSIGN =
TOKEN_TRUE true
TOKEN_OR ||
TOKEN_SUB -
TOKEN_L_PAREN (
TOKEN_INTEGER_LITERAL 4
TOKEN_MUL *
TOKEN_IDENTIFIER x
TOKEN_EXP ^
TOKEN_INTEGER_LITERAL 5
TOKEN_R_PAREN )
TOKEN_ADD +
TOKEN_L_PAREN (
TOKEN_INTEGER_LITERAL 4
TOKEN_SUB -
TOKEN_INTEGER_LITERAL 4
TOKEN_R_PAREN )
TOKEN_GE >=
TOKEN_INTEGER_LITERAL 16
TOKEN_SUB -
TOKEN_INTEGER_LITERAL 6
TOKEN_MUL *
TOKEN_INTEGER_LITERAL 3
TOKEN_ADD +
TOKEN_IDENTIFIER x
TOKEN_AND &&
TOKEN_IDENTIFIER y
TOKEN_EXP ^
TOKEN_INTEGER_LITERAL 2
TOKEN_EQUAL ==
TOKEN_INTEGER_LITERAL 16
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_EOF 
Parse successful


return code: 0


===[good5.bminor Input]===
// test block creations
x:integer;
main:function void() = {
	for(;;)
	{
		x:integer = 5;
		{
			x:integer = 6;
			print x;
		}
	}

	if(x > 5)
	{
		x++;
	}
}
funct2: function void() = {
	{
		print "hello";
	}
	if(x > 5)
		if(x < 5)
		{
			x++;
		}
	else
	{
		x++;
		x--;
	}		
	
}
===[good5.bminor Output]===
Success!

TOKEN_CPP_COMMENT // test block creations
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER main
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_FOR for
TOKEN_L_PAREN (
TOKEN_SEMICOLON ;
TOKEN_SEMICOLON ;
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 5
TOKEN_SEMICOLON ;
TOKEN_L_BRACE {
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 6
TOKEN_SEMICOLON ;
TOKEN_PRINT print
TOKEN_IDENTIFIER x
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_R_BRACE }
TOKEN_IF if
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_GREATER >
TOKEN_INTEGER_LITERAL 5
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_IDENTIFIER x
TOKEN_POSTINC ++
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_R_BRACE }
TOKEN_IDENTIFIER funct2
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_L_BRACE {
TOKEN_PRINT print
TOKEN_STRING_LITERAL hello
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_IF if
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_GREATER >
TOKEN_INTEGER_LITERAL 5
TOKEN_R_PAREN )
TOKEN_IF if
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_LESS <
TOKEN_INTEGER_LITERAL 5
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_IDENTIFIER x
TOKEN_POSTINC ++
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_ELSE else
TOKEN_L_BRACE {
TOKEN_IDENTIFIER x
TOKEN_POSTINC ++
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER x
TOKEN_POSTDEC --
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_R_BRACE }
TOKEN_EOF 
Parse successful


return code: 0


===[good6.bminor Input]===
// basic if else works with & without blocks
main:function void() = {
	if( 10 < 20 )
		print "hi";
	else
		print "hello";
	if( 10 < 20 )
	{
		print "hi";
	}
	else
	{
		print "hello";
	}
}
===[good6.bminor Output]===
Success!

TOKEN_CPP_COMMENT // basic if else works with & without blocks
TOKEN_IDENTIFIER main
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_IF if
TOKEN_L_PAREN (
TOKEN_INTEGER_LITERAL 10
TOKEN_LESS <
TOKEN_INTEGER_LITERAL 20
TOKEN_R_PAREN )
TOKEN_PRINT print
TOKEN_STRING_LITERAL hi
TOKEN_SEMICOLON ;
TOKEN_ELSE else
TOKEN_PRINT print
TOKEN_STRING_LITERAL hello
TOKEN_SEMICOLON ;
TOKEN_IF if
TOKEN_L_PAREN (
TOKEN_INTEGER_LITERAL 10
TOKEN_LESS <
TOKEN_INTEGER_LITERAL 20
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_PRINT print
TOKEN_STRING_LITERAL hi
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_ELSE else
TOKEN_L_BRACE {
TOKEN_PRINT print
TOKEN_STRING_LITERAL hello
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_R_BRACE }
TOKEN_EOF 
Parse successful


return code: 0


===[good7.bminor Input]===
//if else 

main: function void() = {
	x:integer = 5;
	if( 4 < 5 )
		if( 10 < 20 )
			for(x = 0; x < 5; x++)
				if( 4 < 5 )
					print "helloo\n";
				else
					print "hello\n";
		else
			print "goodbye";
}
===[good7.bminor Output]===
Success!

TOKEN_CPP_COMMENT //if else 
TOKEN_IDENTIFIER main
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 5
TOKEN_SEMICOLON ;
TOKEN_IF if
TOKEN_L_PAREN (
TOKEN_INTEGER_LITERAL 4
TOKEN_LESS <
TOKEN_INTEGER_LITERAL 5
TOKEN_R_PAREN )
TOKEN_IF if
TOKEN_L_PAREN (
TOKEN_INTEGER_LITERAL 10
TOKEN_LESS <
TOKEN_INTEGER_LITERAL 20
TOKEN_R_PAREN )
TOKEN_FOR for
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 0
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER x
TOKEN_LESS <
TOKEN_INTEGER_LITERAL 5
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER x
TOKEN_POSTINC ++
TOKEN_R_PAREN )
TOKEN_IF if
TOKEN_L_PAREN (
TOKEN_INTEGER_LITERAL 4
TOKEN_LESS <
TOKEN_INTEGER_LITERAL 5
TOKEN_R_PAREN )
TOKEN_PRINT print
TOKEN_STRING_LITERAL helloo

TOKEN_SEMICOLON ;
TOKEN_ELSE else
TOKEN_PRINT print
TOKEN_STRING_LITERAL hello

TOKEN_SEMICOLON ;
TOKEN_ELSE else
TOKEN_PRINT print
TOKEN_STRING_LITERAL goodbye
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_EOF 
Parse successful


return code: 0


===[good8.bminor Input]===
//tests param lists
fxn: function integer (x:integer)=
{
	return x++;
}

fxn2: function char (x:integer, y:char, z:boolean)=
{
	if(y=='z')
		return 'Z';
	else
		return 'z';
}

fxn3: function char (x: array [] integer, y:char, z: array [] array [] boolean)=
{
	if(y=='z')
		return 'Z';
	else
		return 'z';
}
===[good8.bminor Output]===
Success!

TOKEN_CPP_COMMENT //tests param lists
TOKEN_IDENTIFIER fxn
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_INTEGER integer
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_RETURN return
TOKEN_IDENTIFIER x
TOKEN_POSTINC ++
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_IDENTIFIER fxn2
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_CHARACTER char
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_COMMA ,
TOKEN_IDENTIFIER y
TOKEN_COLON :
TOKEN_CHARACTER char
TOKEN_COMMA ,
TOKEN_IDENTIFIER z
TOKEN_COLON :
TOKEN_BOOLEAN boolean
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_IF if
TOKEN_L_PAREN (
TOKEN_IDENTIFIER y
TOKEN_EQUAL ==
TOKEN_CHARACTER_LITERAL 'z'
TOKEN_R_PAREN )
TOKEN_RETURN return
TOKEN_CHARACTER_LITERAL 'Z'
TOKEN_SEMICOLON ;
TOKEN_ELSE else
TOKEN_RETURN return
TOKEN_CHARACTER_LITERAL 'z'
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_IDENTIFIER fxn3
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_CHARACTER char
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_ARRAY array
TOKEN_L_BRACKET [
TOKEN_R_BRACKET ]
TOKEN_INTEGER integer
TOKEN_COMMA ,
TOKEN_IDENTIFIER y
TOKEN_COLON :
TOKEN_CHARACTER char
TOKEN_COMMA ,
TOKEN_IDENTIFIER z
TOKEN_COLON :
TOKEN_ARRAY array
TOKEN_L_BRACKET [
TOKEN_R_BRACKET ]
TOKEN_ARRAY array
TOKEN_L_BRACKET [
TOKEN_R_BRACKET ]
TOKEN_BOOLEAN boolean
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_IF if
TOKEN_L_PAREN (
TOKEN_IDENTIFIER y
TOKEN_EQUAL ==
TOKEN_CHARACTER_LITERAL 'z'
TOKEN_R_PAREN )
TOKEN_RETURN return
TOKEN_CHARACTER_LITERAL 'Z'
TOKEN_SEMICOLON ;
TOKEN_ELSE else
TOKEN_RETURN return
TOKEN_CHARACTER_LITERAL 'z'
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_EOF 
Parse successful


return code: 0


===[good9.bminor Input]===
//some variable usages
x:integer;
y:integer;
z:integer;
arr:array[5] array[5] integer;
str: string = "hello world";
fxn : function  integer () =
{
	arr[3][2] = 5;
	x = arr[2][3];
	x++;
	return z;
	c:char = str[0];
}
===[good9.bminor Output]===
Success!

TOKEN_CPP_COMMENT //some variable usages
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER y
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER z
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER arr
TOKEN_COLON :
TOKEN_ARRAY array
TOKEN_L_BRACKET [
TOKEN_INTEGER_LITERAL 5
TOKEN_R_BRACKET ]
TOKEN_ARRAY array
TOKEN_L_BRACKET [
TOKEN_INTEGER_LITERAL 5
TOKEN_R_BRACKET ]
TOKEN_INTEGER integer
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER str
TOKEN_COLON :
TOKEN_STRING string
TOKEN_ASSIGN =
TOKEN_STRING_LITERAL hello world
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER fxn
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_INTEGER integer
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_IDENTIFIER arr
TOKEN_L_BRACKET [
TOKEN_INTEGER_LITERAL 3
TOKEN_R_BRACKET ]
TOKEN_L_BRACKET [
TOKEN_INTEGER_LITERAL 2
TOKEN_R_BRACKET ]
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 5
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER x
TOKEN_ASSIGN =
TOKEN_IDENTIFIER arr
TOKEN_L_BRACKET [
TOKEN_INTEGER_LITERAL 2
TOKEN_R_BRACKET ]
TOKEN_L_BRACKET [
TOKEN_INTEGER_LITERAL 3
TOKEN_R_BRACKET ]
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER x
TOKEN_POSTINC ++
TOKEN_SEMICOLON ;
TOKEN_RETURN return
TOKEN_IDENTIFIER z
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER c
TOKEN_COLON :
TOKEN_CHARACTER char
TOKEN_ASSIGN =
TOKEN_IDENTIFIER str
TOKEN_L_BRACKET [
TOKEN_INTEGER_LITERAL 0
TOKEN_R_BRACKET ]
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_EOF 
Parse successful


return code: 0


====Bad Tests====
===[bad0.bminor Input]===
//bad scanning

11111111111111111111111111111111111111111111111111111111111111 + 2;
===[bad0.bminor Output]===
Success!

TOKEN_CPP_COMMENT //bad scanning
Scan error, invalid integer: 11111111111111111111111111111111111111111111111111111111111111


return code: 1


===[bad1.bminor Input]===
// two multiples should generate parse error
main: function void() =
{
	x:integer = 5 ** 5;
	print x;
}

===[bad1.bminor Output]===
Success!

TOKEN_CPP_COMMENT // two multiples should generate parse error
TOKEN_IDENTIFIER main
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 5
TOKEN_MUL *
TOKEN_MUL *
TOKEN_INTEGER_LITERAL 5
TOKEN_SEMICOLON ;
TOKEN_PRINT print
TOKEN_IDENTIFIER x
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_EOF 
parse error: syntax error


return code: 1


===[bad10.bminor Input]===
// test else without a if to match it
x:integer;
funct2: function void() = {
			if(x < 5)
			{
				x++;
			}
			else
			{
				x++;
				x--;
			}
		 
	else 
	{
		print "error, this shouldn't work";
	}
			
	
}

===[bad10.bminor Output]===
Success!

TOKEN_CPP_COMMENT // test else without a if to match it
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER funct2
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_IF if
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_LESS <
TOKEN_INTEGER_LITERAL 5
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_IDENTIFIER x
TOKEN_POSTINC ++
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_ELSE else
TOKEN_L_BRACE {
TOKEN_IDENTIFIER x
TOKEN_POSTINC ++
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER x
TOKEN_POSTDEC --
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_ELSE else
TOKEN_L_BRACE {
TOKEN_PRINT print
TOKEN_STRING_LITERAL error, this shouldn't work
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_R_BRACE }
TOKEN_EOF 
parse error: syntax error


return code: 1


===[bad11.bminor Input]===
// test function calls with wrong format in calls

main: function void () =
{
	print x;
	func3(4 y, z);
}

===[bad11.bminor Output]===
Success!

TOKEN_CPP_COMMENT // test function calls with wrong format in calls
TOKEN_IDENTIFIER main
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_PRINT print
TOKEN_IDENTIFIER x
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER func3
TOKEN_L_PAREN (
TOKEN_INTEGER_LITERAL 4
TOKEN_IDENTIFIER y
TOKEN_COMMA ,
TOKEN_IDENTIFIER z
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_EOF 
parse error: syntax error


return code: 1


===[bad12.bminor Input]===
//test functions without equal signs in definition
main: function void () = {
	print "goodbye";
}
main2:function void () {
	print "hello";
}

===[bad12.bminor Output]===
Success!

TOKEN_CPP_COMMENT //test functions without equal signs in definition
TOKEN_IDENTIFIER main
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_PRINT print
TOKEN_STRING_LITERAL goodbye
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_IDENTIFIER main2
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_PRINT print
TOKEN_STRING_LITERAL hello
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_EOF 
parse error: syntax error


return code: 1


===[bad13.bminor Input]===
// test function without closing brace
x:integer = 6;
fxn:function void() =
{
	integer= 5; 
	
	
}

===[bad13.bminor Output]===
Success!

TOKEN_CPP_COMMENT // test function without closing brace
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 6
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER fxn
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 5
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_EOF 
parse error: syntax error


return code: 1


===[bad14.bminor Input]===
// unmatched {
x:function(y:integer)=
{


===[bad14.bminor Output]===
Success!

TOKEN_CPP_COMMENT // unmatched {
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_L_PAREN (
TOKEN_IDENTIFIER y
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_EOF 
parse error: syntax error


return code: 1


===[bad15.bminor Input]===
//arrays must have brackets in decleration
x:array integer = {1, 2,3,4};

===[bad15.bminor Output]===
Success!

TOKEN_CPP_COMMENT //arrays must have brackets in decleration
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_ARRAY array
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_INTEGER_LITERAL 1
TOKEN_COMMA ,
TOKEN_INTEGER_LITERAL 2
TOKEN_COMMA ,
TOKEN_INTEGER_LITERAL 3
TOKEN_COMMA ,
TOKEN_INTEGER_LITERAL 4
TOKEN_R_BRACE }
TOKEN_SEMICOLON ;
TOKEN_EOF 
parse error: syntax error


return code: 1


===[bad16.bminor Input]===
arr: array [5] = {1,2,3,4, };
===[bad16.bminor Output]===
Success!

TOKEN_IDENTIFIER arr
TOKEN_COLON :
TOKEN_ARRAY array
TOKEN_L_BRACKET [
TOKEN_INTEGER_LITERAL 5
TOKEN_R_BRACKET ]
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_INTEGER_LITERAL 1
TOKEN_COMMA ,
TOKEN_INTEGER_LITERAL 2
TOKEN_COMMA ,
TOKEN_INTEGER_LITERAL 3
TOKEN_COMMA ,
TOKEN_INTEGER_LITERAL 4
TOKEN_COMMA ,
TOKEN_R_BRACE }
TOKEN_SEMICOLON ;
TOKEN_EOF 
parse error: syntax error


return code: 1


===[bad17.bminor Input]===
f(1,2, );
===[bad17.bminor Output]===
Success!

TOKEN_IDENTIFIER f
TOKEN_L_PAREN (
TOKEN_INTEGER_LITERAL 1
TOKEN_COMMA ,
TOKEN_INTEGER_LITERAL 2
TOKEN_COMMA ,
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_EOF 
parse error: syntax error


return code: 1


===[bad18.bminor Input]===
print x,y, ;
===[bad18.bminor Output]===
Success!

TOKEN_PRINT print
TOKEN_IDENTIFIER x
TOKEN_COMMA ,
TOKEN_IDENTIFIER y
TOKEN_COMMA ,
TOKEN_SEMICOLON ;
TOKEN_EOF 
parse error: syntax error


return code: 1


===[bad19.bminor Input]===
for(;){
    x = 5;
}
===[bad19.bminor Output]===
Success!

TOKEN_FOR for
TOKEN_L_PAREN (
TOKEN_SEMICOLON ;
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_IDENTIFIER x
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 5
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_EOF 
parse error: syntax error


return code: 1


===[bad2.bminor Input]===
// semicolon isn't a statement
fxn:function void() =
{
	;
}

===[bad2.bminor Output]===
Success!

TOKEN_CPP_COMMENT // semicolon isn't a statement
TOKEN_IDENTIFIER fxn
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_EOF 
parse error: syntax error


return code: 1


===[bad20.bminor Input]===
for(i=0;i<10,j<10;i++) {  }
===[bad20.bminor Output]===
Success!

TOKEN_FOR for
TOKEN_L_PAREN (
TOKEN_IDENTIFIER i
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 0
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER i
TOKEN_LESS <
TOKEN_INTEGER_LITERAL 10
TOKEN_COMMA ,
TOKEN_IDENTIFIER j
TOKEN_LESS <
TOKEN_INTEGER_LITERAL 10
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER i
TOKEN_POSTINC ++
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_R_BRACE }
TOKEN_EOF 
parse error: syntax error


return code: 1


===[bad3.bminor Input]===
// can't use anything but print in this form
printf "hello world", x, y;

===[bad3.bminor Output]===
Success!

TOKEN_CPP_COMMENT // can't use anything but print in this form
TOKEN_IDENTIFIER printf
TOKEN_STRING_LITERAL hello world
TOKEN_COMMA ,
TOKEN_IDENTIFIER x
TOKEN_COMMA ,
TOKEN_IDENTIFIER y
TOKEN_SEMICOLON ;
TOKEN_EOF 
parse error: syntax error


return code: 1


===[bad4.bminor Input]===
// for loop without correct # of args
main:function void()=
{
	for(i=0; i++) {
		print i;
	}
}

===[bad4.bminor Output]===
Success!

TOKEN_CPP_COMMENT // for loop without correct # of args
TOKEN_IDENTIFIER main
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_FOR for
TOKEN_L_PAREN (
TOKEN_IDENTIFIER i
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 0
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER i
TOKEN_POSTINC ++
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_PRINT print
TOKEN_IDENTIFIER i
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_R_BRACE }
TOKEN_EOF 
parse error: syntax error


return code: 1


===[bad5.bminor Input]===
//print not seperated by ,'s
x:intger = 5;
main:function void()
{
	print x x "hello";
}

===[bad5.bminor Output]===
Success!

TOKEN_CPP_COMMENT //print not seperated by ,'s
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_IDENTIFIER intger
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 5
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER main
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_PRINT print
TOKEN_IDENTIFIER x
TOKEN_IDENTIFIER x
TOKEN_STRING_LITERAL hello
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_EOF 
parse error: syntax error


return code: 1


===[bad6.bminor Input]===
// expressions must end with ;
x:integer = 5;

main:function void()=
{
	x++;
	x++
}

===[bad6.bminor Output]===
Success!

TOKEN_CPP_COMMENT // expressions must end with ;
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 5
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER main
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_IDENTIFIER x
TOKEN_POSTINC ++
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER x
TOKEN_POSTINC ++
TOKEN_R_BRACE }
TOKEN_EOF 
parse error: syntax error


return code: 1


===[bad7.bminor Input]===
// if must be matched
x:integer = 5;
main:function void()=
{
	x++;
	if(x > 5)
}

===[bad7.bminor Output]===
Success!

TOKEN_CPP_COMMENT // if must be matched
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 5
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER main
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_IDENTIFIER x
TOKEN_POSTINC ++
TOKEN_SEMICOLON ;
TOKEN_IF if
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_GREATER >
TOKEN_INTEGER_LITERAL 5
TOKEN_R_PAREN )
TOKEN_R_BRACE }
TOKEN_EOF 
parse error: syntax error


return code: 1


===[bad8.bminor Input]===
//checking param lists
main:function void("hello", x:integer) =
{
	print x;
}

===[bad8.bminor Output]===
Success!

TOKEN_CPP_COMMENT //checking param lists
TOKEN_IDENTIFIER main
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_STRING_LITERAL hello
TOKEN_COMMA ,
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_PRINT print
TOKEN_IDENTIFIER x
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_EOF 
parse error: syntax error


return code: 1


===[bad9.bminor Input]===
//checking param lists with trailing ,
main:function void(hello:string, )=
{
	print hello;
}

===[bad9.bminor Output]===
Success!

TOKEN_CPP_COMMENT //checking param lists with trailing ,
TOKEN_IDENTIFIER main
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_IDENTIFIER hello
TOKEN_COLON :
TOKEN_STRING string
TOKEN_COMMA ,
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_PRINT print
TOKEN_IDENTIFIER hello
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_EOF 
parse error: syntax error


return code: 1


=====HIDDEN TESTS=====
====Good Tests====
===[good1.bminor Input]===
/* A program is a sequence of declarations */
/* Try a variety of variable declarations. */

n: integer;
m: integer = 20;

b: boolean;
c: boolean = true;
s: string;
t: string = "hello\n";
d: char;
e: char = 'x';

x: array [] string;
y: array [] string = { "a", "b", "c" };
z: array [] array [] string = { {"a","b","c"}, {"x","y","z"} };

g: array [3] string;
h: array [3] string = { "a", "b", "c" };
i: array [2] array [3] string = { {"a","b","c"}, {"x","y","z"} };

===[good1.bminor Output]===
Success!

TOKEN_IDENTIFIER n
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER m
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 20
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER b
TOKEN_COLON :
TOKEN_BOOLEAN boolean
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER c
TOKEN_COLON :
TOKEN_BOOLEAN boolean
TOKEN_ASSIGN =
TOKEN_TRUE true
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER s
TOKEN_COLON :
TOKEN_STRING string
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER t
TOKEN_COLON :
TOKEN_STRING string
TOKEN_ASSIGN =
TOKEN_STRING_LITERAL hello

TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER d
TOKEN_COLON :
TOKEN_CHARACTER char
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER e
TOKEN_COLON :
TOKEN_CHARACTER char
TOKEN_ASSIGN =
TOKEN_CHARACTER_LITERAL 'x'
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_ARRAY array
TOKEN_L_BRACKET [
TOKEN_R_BRACKET ]
TOKEN_STRING string
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER y
TOKEN_COLON :
TOKEN_ARRAY array
TOKEN_L_BRACKET [
TOKEN_R_BRACKET ]
TOKEN_STRING string
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_STRING_LITERAL a
TOKEN_COMMA ,
TOKEN_STRING_LITERAL b
TOKEN_COMMA ,
TOKEN_STRING_LITERAL c
TOKEN_R_BRACE }
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER z
TOKEN_COLON :
TOKEN_ARRAY array
TOKEN_L_BRACKET [
TOKEN_R_BRACKET ]
TOKEN_ARRAY array
TOKEN_L_BRACKET [
TOKEN_R_BRACKET ]
TOKEN_STRING string
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_L_BRACE {
TOKEN_STRING_LITERAL a
TOKEN_COMMA ,
TOKEN_STRING_LITERAL b
TOKEN_COMMA ,
TOKEN_STRING_LITERAL c
TOKEN_R_BRACE }
TOKEN_COMMA ,
TOKEN_L_BRACE {
TOKEN_STRING_LITERAL x
TOKEN_COMMA ,
TOKEN_STRING_LITERAL y
TOKEN_COMMA ,
TOKEN_STRING_LITERAL z
TOKEN_R_BRACE }
TOKEN_R_BRACE }
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER g
TOKEN_COLON :
TOKEN_ARRAY array
TOKEN_L_BRACKET [
TOKEN_INTEGER_LITERAL 3
TOKEN_R_BRACKET ]
TOKEN_STRING string
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER h
TOKEN_COLON :
TOKEN_ARRAY array
TOKEN_L_BRACKET [
TOKEN_INTEGER_LITERAL 3
TOKEN_R_BRACKET ]
TOKEN_STRING string
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_STRING_LITERAL a
TOKEN_COMMA ,
TOKEN_STRING_LITERAL b
TOKEN_COMMA ,
TOKEN_STRING_LITERAL c
TOKEN_R_BRACE }
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER i
TOKEN_COLON :
TOKEN_ARRAY array
TOKEN_L_BRACKET [
TOKEN_INTEGER_LITERAL 2
TOKEN_R_BRACKET ]
TOKEN_ARRAY array
TOKEN_L_BRACKET [
TOKEN_INTEGER_LITERAL 3
TOKEN_R_BRACKET ]
TOKEN_STRING string
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_L_BRACE {
TOKEN_STRING_LITERAL a
TOKEN_COMMA ,
TOKEN_STRING_LITERAL b
TOKEN_COMMA ,
TOKEN_STRING_LITERAL c
TOKEN_R_BRACE }
TOKEN_COMMA ,
TOKEN_L_BRACE {
TOKEN_STRING_LITERAL x
TOKEN_COMMA ,
TOKEN_STRING_LITERAL y
TOKEN_COMMA ,
TOKEN_STRING_LITERAL z
TOKEN_R_BRACE }
TOKEN_R_BRACE }
TOKEN_SEMICOLON ;
TOKEN_EOF 
Parse successful


return code: 0


===[good10.bminor Input]===
/* Try accesssing arrays of various sizes; */

a: array [10] integer = {100,200,300,400,500,600,700,800,900};
b: array [10] integer;
c: array [10] array [10] integer;

testfunc: function void () = {
    i: integer;
    j: integer;

    for(i=0;i<10;i++) {
        b[i] = a[i] * 10;
    }

    for(i=0;i<5;i++) {
        b[i*2] = a[i] + b[i];
    }

    for(j=0;j<10;i++) {
        for(i=0;i<10;i++) {
            c[i][j] = i*j;
        }
    }

    for(j=0;j<10;i++) {
        for(i=0;i<10;i++) {
            print c[i][j];
            print " ";
        }
        print "\n";
    }
}

===[good10.bminor Output]===
Success!

TOKEN_IDENTIFIER a
TOKEN_COLON :
TOKEN_ARRAY array
TOKEN_L_BRACKET [
TOKEN_INTEGER_LITERAL 10
TOKEN_R_BRACKET ]
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_INTEGER_LITERAL 100
TOKEN_COMMA ,
TOKEN_INTEGER_LITERAL 200
TOKEN_COMMA ,
TOKEN_INTEGER_LITERAL 300
TOKEN_COMMA ,
TOKEN_INTEGER_LITERAL 400
TOKEN_COMMA ,
TOKEN_INTEGER_LITERAL 500
TOKEN_COMMA ,
TOKEN_INTEGER_LITERAL 600
TOKEN_COMMA ,
TOKEN_INTEGER_LITERAL 700
TOKEN_COMMA ,
TOKEN_INTEGER_LITERAL 800
TOKEN_COMMA ,
TOKEN_INTEGER_LITERAL 900
TOKEN_R_BRACE }
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER b
TOKEN_COLON :
TOKEN_ARRAY array
TOKEN_L_BRACKET [
TOKEN_INTEGER_LITERAL 10
TOKEN_R_BRACKET ]
TOKEN_INTEGER integer
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER c
TOKEN_COLON :
TOKEN_ARRAY array
TOKEN_L_BRACKET [
TOKEN_INTEGER_LITERAL 10
TOKEN_R_BRACKET ]
TOKEN_ARRAY array
TOKEN_L_BRACKET [
TOKEN_INTEGER_LITERAL 10
TOKEN_R_BRACKET ]
TOKEN_INTEGER integer
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER testfunc
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_IDENTIFIER i
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER j
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_SEMICOLON ;
TOKEN_FOR for
TOKEN_L_PAREN (
TOKEN_IDENTIFIER i
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 0
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER i
TOKEN_LESS <
TOKEN_INTEGER_LITERAL 10
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER i
TOKEN_POSTINC ++
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_IDENTIFIER b
TOKEN_L_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_R_BRACKET ]
TOKEN_ASSIGN =
TOKEN_IDENTIFIER a
TOKEN_L_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_R_BRACKET ]
TOKEN_MUL *
TOKEN_INTEGER_LITERAL 10
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_FOR for
TOKEN_L_PAREN (
TOKEN_IDENTIFIER i
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 0
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER i
TOKEN_LESS <
TOKEN_INTEGER_LITERAL 5
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER i
TOKEN_POSTINC ++
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_IDENTIFIER b
TOKEN_L_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_MUL *
TOKEN_INTEGER_LITERAL 2
TOKEN_R_BRACKET ]
TOKEN_ASSIGN =
TOKEN_IDENTIFIER a
TOKEN_L_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_R_BRACKET ]
TOKEN_ADD +
TOKEN_IDENTIFIER b
TOKEN_L_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_R_BRACKET ]
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_FOR for
TOKEN_L_PAREN (
TOKEN_IDENTIFIER j
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 0
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER j
TOKEN_LESS <
TOKEN_INTEGER_LITERAL 10
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER i
TOKEN_POSTINC ++
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_FOR for
TOKEN_L_PAREN (
TOKEN_IDENTIFIER i
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 0
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER i
TOKEN_LESS <
TOKEN_INTEGER_LITERAL 10
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER i
TOKEN_POSTINC ++
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_IDENTIFIER c
TOKEN_L_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_R_BRACKET ]
TOKEN_L_BRACKET [
TOKEN_IDENTIFIER j
TOKEN_R_BRACKET ]
TOKEN_ASSIGN =
TOKEN_IDENTIFIER i
TOKEN_MUL *
TOKEN_IDENTIFIER j
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_R_BRACE }
TOKEN_FOR for
TOKEN_L_PAREN (
TOKEN_IDENTIFIER j
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 0
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER j
TOKEN_LESS <
TOKEN_INTEGER_LITERAL 10
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER i
TOKEN_POSTINC ++
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_FOR for
TOKEN_L_PAREN (
TOKEN_IDENTIFIER i
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 0
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER i
TOKEN_LESS <
TOKEN_INTEGER_LITERAL 10
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER i
TOKEN_POSTINC ++
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_PRINT print
TOKEN_IDENTIFIER c
TOKEN_L_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_R_BRACKET ]
TOKEN_L_BRACKET [
TOKEN_IDENTIFIER j
TOKEN_R_BRACKET ]
TOKEN_SEMICOLON ;
TOKEN_PRINT print
TOKEN_STRING_LITERAL  
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_PRINT print
TOKEN_STRING_LITERAL 

TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_R_BRACE }
TOKEN_EOF 
Parse successful


return code: 0


===[good11.bminor Input]===

/* Try locally declared array lengths */


testfunc: function void (x: integer, y: integer) = {
    i: integer;
    j: integer;

    a: array [10] integer = {100,200,300,400,500,600,700,800,900};
    b: array [x] integer;
    c: array [x] array [y] integer;

    for(i=0;i<10;i++) {
        b[i] = a[i] * 10;
    }

    for(i=0;i<5;i++) {
        b[i*2] = a[i] + b[i];
    }

    for(j=0;j<10;i++) {
        for(i=0;i<10;i++) {
            c[i][j] = i*j;
        }
    }

    for(j=0;j<10;i++) {
        for(i=0;i<10;i++) {
            print c[i][j];
            print " ";
        }
        print "\n";
    }
}

===[good11.bminor Output]===
Success!

TOKEN_IDENTIFIER testfunc
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_COMMA ,
TOKEN_IDENTIFIER y
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_IDENTIFIER i
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER j
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER a
TOKEN_COLON :
TOKEN_ARRAY array
TOKEN_L_BRACKET [
TOKEN_INTEGER_LITERAL 10
TOKEN_R_BRACKET ]
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_INTEGER_LITERAL 100
TOKEN_COMMA ,
TOKEN_INTEGER_LITERAL 200
TOKEN_COMMA ,
TOKEN_INTEGER_LITERAL 300
TOKEN_COMMA ,
TOKEN_INTEGER_LITERAL 400
TOKEN_COMMA ,
TOKEN_INTEGER_LITERAL 500
TOKEN_COMMA ,
TOKEN_INTEGER_LITERAL 600
TOKEN_COMMA ,
TOKEN_INTEGER_LITERAL 700
TOKEN_COMMA ,
TOKEN_INTEGER_LITERAL 800
TOKEN_COMMA ,
TOKEN_INTEGER_LITERAL 900
TOKEN_R_BRACE }
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER b
TOKEN_COLON :
TOKEN_ARRAY array
TOKEN_L_BRACKET [
TOKEN_IDENTIFIER x
TOKEN_R_BRACKET ]
TOKEN_INTEGER integer
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER c
TOKEN_COLON :
TOKEN_ARRAY array
TOKEN_L_BRACKET [
TOKEN_IDENTIFIER x
TOKEN_R_BRACKET ]
TOKEN_ARRAY array
TOKEN_L_BRACKET [
TOKEN_IDENTIFIER y
TOKEN_R_BRACKET ]
TOKEN_INTEGER integer
TOKEN_SEMICOLON ;
TOKEN_FOR for
TOKEN_L_PAREN (
TOKEN_IDENTIFIER i
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 0
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER i
TOKEN_LESS <
TOKEN_INTEGER_LITERAL 10
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER i
TOKEN_POSTINC ++
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_IDENTIFIER b
TOKEN_L_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_R_BRACKET ]
TOKEN_ASSIGN =
TOKEN_IDENTIFIER a
TOKEN_L_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_R_BRACKET ]
TOKEN_MUL *
TOKEN_INTEGER_LITERAL 10
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_FOR for
TOKEN_L_PAREN (
TOKEN_IDENTIFIER i
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 0
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER i
TOKEN_LESS <
TOKEN_INTEGER_LITERAL 5
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER i
TOKEN_POSTINC ++
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_IDENTIFIER b
TOKEN_L_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_MUL *
TOKEN_INTEGER_LITERAL 2
TOKEN_R_BRACKET ]
TOKEN_ASSIGN =
TOKEN_IDENTIFIER a
TOKEN_L_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_R_BRACKET ]
TOKEN_ADD +
TOKEN_IDENTIFIER b
TOKEN_L_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_R_BRACKET ]
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_FOR for
TOKEN_L_PAREN (
TOKEN_IDENTIFIER j
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 0
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER j
TOKEN_LESS <
TOKEN_INTEGER_LITERAL 10
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER i
TOKEN_POSTINC ++
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_FOR for
TOKEN_L_PAREN (
TOKEN_IDENTIFIER i
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 0
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER i
TOKEN_LESS <
TOKEN_INTEGER_LITERAL 10
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER i
TOKEN_POSTINC ++
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_IDENTIFIER c
TOKEN_L_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_R_BRACKET ]
TOKEN_L_BRACKET [
TOKEN_IDENTIFIER j
TOKEN_R_BRACKET ]
TOKEN_ASSIGN =
TOKEN_IDENTIFIER i
TOKEN_MUL *
TOKEN_IDENTIFIER j
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_R_BRACE }
TOKEN_FOR for
TOKEN_L_PAREN (
TOKEN_IDENTIFIER j
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 0
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER j
TOKEN_LESS <
TOKEN_INTEGER_LITERAL 10
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER i
TOKEN_POSTINC ++
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_FOR for
TOKEN_L_PAREN (
TOKEN_IDENTIFIER i
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 0
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER i
TOKEN_LESS <
TOKEN_INTEGER_LITERAL 10
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER i
TOKEN_POSTINC ++
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_PRINT print
TOKEN_IDENTIFIER c
TOKEN_L_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_R_BRACKET ]
TOKEN_L_BRACKET [
TOKEN_IDENTIFIER j
TOKEN_R_BRACKET ]
TOKEN_SEMICOLON ;
TOKEN_PRINT print
TOKEN_STRING_LITERAL  
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_PRINT print
TOKEN_STRING_LITERAL 

TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_R_BRACE }
TOKEN_EOF 
Parse successful


return code: 0


===[good12.bminor Input]===

/* single statement ifs */

x: integer = 65;
s: string = "hello";
b: boolean = false;

min: function integer ( a: integer, b: integer ) =
{
	if(a > b) return a;
	else return b;
}

testfunc: function void ( z: integer ) =
{
	print "minimum", min(10, 5), "\n";
}

===[good12.bminor Output]===
Success!

TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 65
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER s
TOKEN_COLON :
TOKEN_STRING string
TOKEN_ASSIGN =
TOKEN_STRING_LITERAL hello
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER b
TOKEN_COLON :
TOKEN_BOOLEAN boolean
TOKEN_ASSIGN =
TOKEN_FALSE false
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER min
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_INTEGER integer
TOKEN_L_PAREN (
TOKEN_IDENTIFIER a
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_COMMA ,
TOKEN_IDENTIFIER b
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_IF if
TOKEN_L_PAREN (
TOKEN_IDENTIFIER a
TOKEN_GREATER >
TOKEN_IDENTIFIER b
TOKEN_R_PAREN )
TOKEN_RETURN return
TOKEN_IDENTIFIER a
TOKEN_SEMICOLON ;
TOKEN_ELSE else
TOKEN_RETURN return
TOKEN_IDENTIFIER b
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_IDENTIFIER testfunc
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_IDENTIFIER z
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_PRINT print
TOKEN_STRING_LITERAL minimum
TOKEN_COMMA ,
TOKEN_IDENTIFIER min
TOKEN_L_PAREN (
TOKEN_INTEGER_LITERAL 10
TOKEN_COMMA ,
TOKEN_INTEGER_LITERAL 5
TOKEN_R_PAREN )
TOKEN_COMMA ,
TOKEN_STRING_LITERAL 

TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_EOF 
Parse successful


return code: 0


===[good13.bminor Input]===
/* string format expr */

x: integer = 65;
s: string = "hello";
b: boolean = false;

min: function integer ( a: integer, b: integer ) =
{
	if(a > b) return a;
	else return b;
}

testfunc: function void ( z: integer ) =
{
	print "minimum", min(10, 5), "\n", z=10, z==10;
}
	

===[good13.bminor Output]===
Success!

TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 65
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER s
TOKEN_COLON :
TOKEN_STRING string
TOKEN_ASSIGN =
TOKEN_STRING_LITERAL hello
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER b
TOKEN_COLON :
TOKEN_BOOLEAN boolean
TOKEN_ASSIGN =
TOKEN_FALSE false
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER min
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_INTEGER integer
TOKEN_L_PAREN (
TOKEN_IDENTIFIER a
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_COMMA ,
TOKEN_IDENTIFIER b
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_IF if
TOKEN_L_PAREN (
TOKEN_IDENTIFIER a
TOKEN_GREATER >
TOKEN_IDENTIFIER b
TOKEN_R_PAREN )
TOKEN_RETURN return
TOKEN_IDENTIFIER a
TOKEN_SEMICOLON ;
TOKEN_ELSE else
TOKEN_RETURN return
TOKEN_IDENTIFIER b
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_IDENTIFIER testfunc
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_IDENTIFIER z
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_PRINT print
TOKEN_STRING_LITERAL minimum
TOKEN_COMMA ,
TOKEN_IDENTIFIER min
TOKEN_L_PAREN (
TOKEN_INTEGER_LITERAL 10
TOKEN_COMMA ,
TOKEN_INTEGER_LITERAL 5
TOKEN_R_PAREN )
TOKEN_COMMA ,
TOKEN_STRING_LITERAL 

TOKEN_COMMA ,
TOKEN_IDENTIFIER z
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 10
TOKEN_COMMA ,
TOKEN_IDENTIFIER z
TOKEN_EQUAL ==
TOKEN_INTEGER_LITERAL 10
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_EOF 
Parse successful


return code: 0


===[good14.bminor Input]===

/* returning various expressions */

testfunc: function void ( x: integer, y:integer, z:integer ) = {
	return x;
	return "hello";
	return x = 10;
	return x == 10;
	return x > 5;
	return testfunc(x, y, z);
}

===[good14.bminor Output]===
Success!

TOKEN_IDENTIFIER testfunc
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_COMMA ,
TOKEN_IDENTIFIER y
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_COMMA ,
TOKEN_IDENTIFIER z
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_RETURN return
TOKEN_IDENTIFIER x
TOKEN_SEMICOLON ;
TOKEN_RETURN return
TOKEN_STRING_LITERAL hello
TOKEN_SEMICOLON ;
TOKEN_RETURN return
TOKEN_IDENTIFIER x
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 10
TOKEN_SEMICOLON ;
TOKEN_RETURN return
TOKEN_IDENTIFIER x
TOKEN_EQUAL ==
TOKEN_INTEGER_LITERAL 10
TOKEN_SEMICOLON ;
TOKEN_RETURN return
TOKEN_IDENTIFIER x
TOKEN_GREATER >
TOKEN_INTEGER_LITERAL 5
TOKEN_SEMICOLON ;
TOKEN_RETURN return
TOKEN_IDENTIFIER testfunc
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_COMMA ,
TOKEN_IDENTIFIER y
TOKEN_COMMA ,
TOKEN_IDENTIFIER z
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_EOF 
Parse successful


return code: 0


===[good15.bminor Input]===


/* code blocks */

testfunc: function void ( x: integer, y:integer, z:integer ) = {
	{
		return x;
		return "hello";
		return x = 10;
	}
	{
		return x == 10;
		{
			return x > 5;
			return testfunc(x, y, z);
		}
	}
}

===[good15.bminor Output]===
Success!

TOKEN_IDENTIFIER testfunc
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_COMMA ,
TOKEN_IDENTIFIER y
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_COMMA ,
TOKEN_IDENTIFIER z
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_L_BRACE {
TOKEN_RETURN return
TOKEN_IDENTIFIER x
TOKEN_SEMICOLON ;
TOKEN_RETURN return
TOKEN_STRING_LITERAL hello
TOKEN_SEMICOLON ;
TOKEN_RETURN return
TOKEN_IDENTIFIER x
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 10
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_L_BRACE {
TOKEN_RETURN return
TOKEN_IDENTIFIER x
TOKEN_EQUAL ==
TOKEN_INTEGER_LITERAL 10
TOKEN_SEMICOLON ;
TOKEN_L_BRACE {
TOKEN_RETURN return
TOKEN_IDENTIFIER x
TOKEN_GREATER >
TOKEN_INTEGER_LITERAL 5
TOKEN_SEMICOLON ;
TOKEN_RETURN return
TOKEN_IDENTIFIER testfunc
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_COMMA ,
TOKEN_IDENTIFIER y
TOKEN_COMMA ,
TOKEN_IDENTIFIER z
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_R_BRACE }
TOKEN_R_BRACE }
TOKEN_EOF 
Parse successful


return code: 0


===[good2.bminor Input]===
/* Function prototypes are declarations without bodies. */

ComputeAscii: function char ( c: char );

GetLength: function integer ( s: string, i: integer );

/* Function body has some code in it */

GetArea: function integer ( width: integer, height: integer ) =
{
	return width * height;
}

===[good2.bminor Output]===
Success!

TOKEN_IDENTIFIER ComputeAscii
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_CHARACTER char
TOKEN_L_PAREN (
TOKEN_IDENTIFIER c
TOKEN_COLON :
TOKEN_CHARACTER char
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER GetLength
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_INTEGER integer
TOKEN_L_PAREN (
TOKEN_IDENTIFIER s
TOKEN_COLON :
TOKEN_STRING string
TOKEN_COMMA ,
TOKEN_IDENTIFIER i
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER GetArea
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_INTEGER integer
TOKEN_L_PAREN (
TOKEN_IDENTIFIER width
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_COMMA ,
TOKEN_IDENTIFIER height
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_RETURN return
TOKEN_IDENTIFIER width
TOKEN_MUL *
TOKEN_IDENTIFIER height
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_EOF 
Parse successful


return code: 0


===[good3.bminor Input]===
/* A function contains a sequence of statements */
/* Some of those statements can be decls */

simplefunc: function void () = {
     x: integer;
     y: integer = 20;
     s: string = "hello world";
}

===[good3.bminor Output]===
Success!

TOKEN_IDENTIFIER simplefunc
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER y
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 20
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER s
TOKEN_COLON :
TOKEN_STRING string
TOKEN_ASSIGN =
TOKEN_STRING_LITERAL hello world
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_EOF 
Parse successful


return code: 0


===[good4.bminor Input]===
/* A function contains a sequence of statements */
/* Try decls and stmts and exprs together. */

simplefunc: function boolean ( x: integer, y: integer ) = {

     // A declaration
     z: integer = x * y;

     // An expression with a semicolon
     z = 16 + x / y;

     // Print statement
     print "input is: ", x, " and ", y, "\n";

     // Simple if-else statement
     if( x < y ) {
         return true;
     } else {
         return false;
     }

}

===[good4.bminor Output]===
Success!

TOKEN_IDENTIFIER simplefunc
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_BOOLEAN boolean
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_COMMA ,
TOKEN_IDENTIFIER y
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_CPP_COMMENT // A declaration
TOKEN_IDENTIFIER z
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_IDENTIFIER x
TOKEN_MUL *
TOKEN_IDENTIFIER y
TOKEN_SEMICOLON ;
TOKEN_CPP_COMMENT // An expression with a semicolon
TOKEN_IDENTIFIER z
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 16
TOKEN_ADD +
TOKEN_IDENTIFIER x
TOKEN_DIV /
TOKEN_IDENTIFIER y
TOKEN_SEMICOLON ;
TOKEN_CPP_COMMENT // Print statement
TOKEN_PRINT print
TOKEN_STRING_LITERAL input is: 
TOKEN_COMMA ,
TOKEN_IDENTIFIER x
TOKEN_COMMA ,
TOKEN_STRING_LITERAL  and 
TOKEN_COMMA ,
TOKEN_IDENTIFIER y
TOKEN_COMMA ,
TOKEN_STRING_LITERAL 

TOKEN_SEMICOLON ;
TOKEN_CPP_COMMENT // Simple if-else statement
TOKEN_IF if
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_LESS <
TOKEN_IDENTIFIER y
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_RETURN return
TOKEN_TRUE true
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_ELSE else
TOKEN_L_BRACE {
TOKEN_RETURN return
TOKEN_FALSE false
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_R_BRACE }
TOKEN_EOF 
Parse successful


return code: 0


===[good5.bminor Input]===
/* A function contains a sequence of statements */
/* Try decls and stmts and exprs together. */
/* Add some float */

simplefunc: function boolean ( x: integer, y: integer ) = {

     // A declaration
     z: integer = x * y;
	
     // A float declaration
     q: float = 10e9;
     
     // another float
     v: float = 2.10e2;

     // a float operation
     return v;

}

===[good5.bminor Output]===
TEST NOT PASSED

TOKEN_IDENTIFIER simplefunc
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_BOOLEAN boolean
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_COMMA ,
TOKEN_IDENTIFIER y
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_CPP_COMMENT // A declaration
TOKEN_IDENTIFIER z
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_IDENTIFIER x
TOKEN_MUL *
TOKEN_IDENTIFIER y
TOKEN_SEMICOLON ;
TOKEN_CPP_COMMENT // A float declaration
TOKEN_IDENTIFIER q
TOKEN_COLON :
TOKEN_FLOAT float
TOKEN_ASSIGN =
269 10e9
TOKEN_SEMICOLON ;
TOKEN_CPP_COMMENT // another float
TOKEN_IDENTIFIER v
TOKEN_COLON :
TOKEN_FLOAT float
TOKEN_ASSIGN =
269 2.10
TOKEN_IDENTIFIER e2
TOKEN_SEMICOLON ;
TOKEN_CPP_COMMENT // a float operation
TOKEN_RETURN return
TOKEN_IDENTIFIER v
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_EOF 
parse error: syntax error


return code: 1


===[good6.bminor Input]===
/* Try several variations of for-loops */

simplefunc: function void (r: integer, s: integer, t: integer ) = {

    i: integer;

    for( i=0; i<r; i++ ) {
        print i,"\n";
    }

    i=0;
    for( ; i<s; i++ ) {
        print i,"\n";
    }

    i=0;
    for( ; i<r; ) {
        print i,"\n";
        i++;
    }

    for(;;) print "forever!\n";
}

===[good6.bminor Output]===
Success!

TOKEN_IDENTIFIER simplefunc
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_IDENTIFIER r
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_COMMA ,
TOKEN_IDENTIFIER s
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_COMMA ,
TOKEN_IDENTIFIER t
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_IDENTIFIER i
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_SEMICOLON ;
TOKEN_FOR for
TOKEN_L_PAREN (
TOKEN_IDENTIFIER i
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 0
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER i
TOKEN_LESS <
TOKEN_IDENTIFIER r
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER i
TOKEN_POSTINC ++
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_PRINT print
TOKEN_IDENTIFIER i
TOKEN_COMMA ,
TOKEN_STRING_LITERAL 

TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_IDENTIFIER i
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 0
TOKEN_SEMICOLON ;
TOKEN_FOR for
TOKEN_L_PAREN (
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER i
TOKEN_LESS <
TOKEN_IDENTIFIER s
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER i
TOKEN_POSTINC ++
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_PRINT print
TOKEN_IDENTIFIER i
TOKEN_COMMA ,
TOKEN_STRING_LITERAL 

TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_IDENTIFIER i
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 0
TOKEN_SEMICOLON ;
TOKEN_FOR for
TOKEN_L_PAREN (
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER i
TOKEN_LESS <
TOKEN_IDENTIFIER r
TOKEN_SEMICOLON ;
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_PRINT print
TOKEN_IDENTIFIER i
TOKEN_COMMA ,
TOKEN_STRING_LITERAL 

TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER i
TOKEN_POSTINC ++
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_FOR for
TOKEN_L_PAREN (
TOKEN_SEMICOLON ;
TOKEN_SEMICOLON ;
TOKEN_R_PAREN )
TOKEN_PRINT print
TOKEN_STRING_LITERAL forever!

TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_EOF 
Parse successful


return code: 0


===[good7.bminor Input]===
/* Test various nestings of if-else statements */

testit: function boolean ( x: integer, y: integer ) = {

	/* If statement without braces */
	if( x<y ) print "less\n"; else print "low\n";

	/* If statement with braces */
	if( x<y ) { print "less\n"; } else { print "low\n"; }

	/* This statement should print nothing */
        if(20<10) if(10<20) print "incorrect!"; else print "dangling else!";

	/* statements and decls inside of if-else */

        if( x>y ) {
              i: integer;
              for(i=0;i<x;i++) print i, "\n";
        } else {
              i: integer;
              for(i=0;i<y;i++) print i, "\n";
        }

	/* A decl can come after a few statements */
	i: integer;

	/* try the other way around */
	for(i=0;i<x;i++) {
              if( i<x ) print "small"; else print "large";
        }

        return true;
}

===[good7.bminor Output]===
Success!

TOKEN_IDENTIFIER testit
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_BOOLEAN boolean
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_COMMA ,
TOKEN_IDENTIFIER y
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_IF if
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_LESS <
TOKEN_IDENTIFIER y
TOKEN_R_PAREN )
TOKEN_PRINT print
TOKEN_STRING_LITERAL less

TOKEN_SEMICOLON ;
TOKEN_ELSE else
TOKEN_PRINT print
TOKEN_STRING_LITERAL low

TOKEN_SEMICOLON ;
TOKEN_IF if
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_LESS <
TOKEN_IDENTIFIER y
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_PRINT print
TOKEN_STRING_LITERAL less

TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_ELSE else
TOKEN_L_BRACE {
TOKEN_PRINT print
TOKEN_STRING_LITERAL low

TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_IF if
TOKEN_L_PAREN (
TOKEN_INTEGER_LITERAL 20
TOKEN_LESS <
TOKEN_INTEGER_LITERAL 10
TOKEN_R_PAREN )
TOKEN_IF if
TOKEN_L_PAREN (
TOKEN_INTEGER_LITERAL 10
TOKEN_LESS <
TOKEN_INTEGER_LITERAL 20
TOKEN_R_PAREN )
TOKEN_PRINT print
TOKEN_STRING_LITERAL incorrect!
TOKEN_SEMICOLON ;
TOKEN_ELSE else
TOKEN_PRINT print
TOKEN_STRING_LITERAL dangling else!
TOKEN_SEMICOLON ;
TOKEN_IF if
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_GREATER >
TOKEN_IDENTIFIER y
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_IDENTIFIER i
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_SEMICOLON ;
TOKEN_FOR for
TOKEN_L_PAREN (
TOKEN_IDENTIFIER i
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 0
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER i
TOKEN_LESS <
TOKEN_IDENTIFIER x
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER i
TOKEN_POSTINC ++
TOKEN_R_PAREN )
TOKEN_PRINT print
TOKEN_IDENTIFIER i
TOKEN_COMMA ,
TOKEN_STRING_LITERAL 

TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_ELSE else
TOKEN_L_BRACE {
TOKEN_IDENTIFIER i
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_SEMICOLON ;
TOKEN_FOR for
TOKEN_L_PAREN (
TOKEN_IDENTIFIER i
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 0
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER i
TOKEN_LESS <
TOKEN_IDENTIFIER y
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER i
TOKEN_POSTINC ++
TOKEN_R_PAREN )
TOKEN_PRINT print
TOKEN_IDENTIFIER i
TOKEN_COMMA ,
TOKEN_STRING_LITERAL 

TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_IDENTIFIER i
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_SEMICOLON ;
TOKEN_FOR for
TOKEN_L_PAREN (
TOKEN_IDENTIFIER i
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 0
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER i
TOKEN_LESS <
TOKEN_IDENTIFIER x
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER i
TOKEN_POSTINC ++
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_IF if
TOKEN_L_PAREN (
TOKEN_IDENTIFIER i
TOKEN_LESS <
TOKEN_IDENTIFIER x
TOKEN_R_PAREN )
TOKEN_PRINT print
TOKEN_STRING_LITERAL small
TOKEN_SEMICOLON ;
TOKEN_ELSE else
TOKEN_PRINT print
TOKEN_STRING_LITERAL large
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_RETURN return
TOKEN_TRUE true
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_EOF 
Parse successful


return code: 0


===[good8.bminor Input]===
/* Now try some expressions */

x: integer = 65;
s: string = "hello";
b: boolean = false;

min: function integer ( a: integer, b: integer ) =
{
	if( a<b ) return a; else return b;
}

testfunc: function void ( z: integer ) =
{
	// Nested integer operators.
	y: integer = x*(x*10 + 55%6 + z/10);
	print "y: ", y, "\n";

	// Nested boolean operations.
	c: boolean = ( x<100 && y>200 ) || !(b=true);
	print "c: ", c, "\n";

	// Boolean operations on strings?
	d: boolean = (s == "goodbye");
	print "d: ", d, "\n";

	// Can we stack up assignments?
	z = y = x;

	a: array [100] integer;

	// Function calls and array accesses:
	y = min(a[10],a[20]);
}

===[good8.bminor Output]===
Success!

TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 65
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER s
TOKEN_COLON :
TOKEN_STRING string
TOKEN_ASSIGN =
TOKEN_STRING_LITERAL hello
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER b
TOKEN_COLON :
TOKEN_BOOLEAN boolean
TOKEN_ASSIGN =
TOKEN_FALSE false
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER min
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_INTEGER integer
TOKEN_L_PAREN (
TOKEN_IDENTIFIER a
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_COMMA ,
TOKEN_IDENTIFIER b
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_IF if
TOKEN_L_PAREN (
TOKEN_IDENTIFIER a
TOKEN_LESS <
TOKEN_IDENTIFIER b
TOKEN_R_PAREN )
TOKEN_RETURN return
TOKEN_IDENTIFIER a
TOKEN_SEMICOLON ;
TOKEN_ELSE else
TOKEN_RETURN return
TOKEN_IDENTIFIER b
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_IDENTIFIER testfunc
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_IDENTIFIER z
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_CPP_COMMENT // Nested integer operators.
TOKEN_IDENTIFIER y
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_IDENTIFIER x
TOKEN_MUL *
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_MUL *
TOKEN_INTEGER_LITERAL 10
TOKEN_ADD +
TOKEN_INTEGER_LITERAL 55
TOKEN_MOD %
TOKEN_INTEGER_LITERAL 6
TOKEN_ADD +
TOKEN_IDENTIFIER z
TOKEN_DIV /
TOKEN_INTEGER_LITERAL 10
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_PRINT print
TOKEN_STRING_LITERAL y: 
TOKEN_COMMA ,
TOKEN_IDENTIFIER y
TOKEN_COMMA ,
TOKEN_STRING_LITERAL 

TOKEN_SEMICOLON ;
TOKEN_CPP_COMMENT // Nested boolean operations.
TOKEN_IDENTIFIER c
TOKEN_COLON :
TOKEN_BOOLEAN boolean
TOKEN_ASSIGN =
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_LESS <
TOKEN_INTEGER_LITERAL 100
TOKEN_AND &&
TOKEN_IDENTIFIER y
TOKEN_GREATER >
TOKEN_INTEGER_LITERAL 200
TOKEN_R_PAREN )
TOKEN_OR ||
TOKEN_NOT !
TOKEN_L_PAREN (
TOKEN_IDENTIFIER b
TOKEN_ASSIGN =
TOKEN_TRUE true
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_PRINT print
TOKEN_STRING_LITERAL c: 
TOKEN_COMMA ,
TOKEN_IDENTIFIER c
TOKEN_COMMA ,
TOKEN_STRING_LITERAL 

TOKEN_SEMICOLON ;
TOKEN_CPP_COMMENT // Boolean operations on strings?
TOKEN_IDENTIFIER d
TOKEN_COLON :
TOKEN_BOOLEAN boolean
TOKEN_ASSIGN =
TOKEN_L_PAREN (
TOKEN_IDENTIFIER s
TOKEN_EQUAL ==
TOKEN_STRING_LITERAL goodbye
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_PRINT print
TOKEN_STRING_LITERAL d: 
TOKEN_COMMA ,
TOKEN_IDENTIFIER d
TOKEN_COMMA ,
TOKEN_STRING_LITERAL 

TOKEN_SEMICOLON ;
TOKEN_CPP_COMMENT // Can we stack up assignments?
TOKEN_IDENTIFIER z
TOKEN_ASSIGN =
TOKEN_IDENTIFIER y
TOKEN_ASSIGN =
TOKEN_IDENTIFIER x
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER a
TOKEN_COLON :
TOKEN_ARRAY array
TOKEN_L_BRACKET [
TOKEN_INTEGER_LITERAL 100
TOKEN_R_BRACKET ]
TOKEN_INTEGER integer
TOKEN_SEMICOLON ;
TOKEN_CPP_COMMENT // Function calls and array accesses:
TOKEN_IDENTIFIER y
TOKEN_ASSIGN =
TOKEN_IDENTIFIER min
TOKEN_L_PAREN (
TOKEN_IDENTIFIER a
TOKEN_L_BRACKET [
TOKEN_INTEGER_LITERAL 10
TOKEN_R_BRACKET ]
TOKEN_COMMA ,
TOKEN_IDENTIFIER a
TOKEN_L_BRACKET [
TOKEN_INTEGER_LITERAL 20
TOKEN_R_BRACKET ]
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_EOF 
Parse successful


return code: 0


===[good9.bminor Input]===
/* Check for minimum use of parentheses. */

testfunc: function void ( x: integer, y:integer, z:integer ) = {

          r: integer;
	  b: boolean;

          // Parens required
	  r = (x+y)/z;
	  r = x+(y+z);
	  b = (true||false) && (false||true);

          // Parens not required
	  r = x+(y/z);
	  r = (x+y)+z;
	  b = (x+y) < (x+z);
	  b = (true&&false) || (false&&true);

}

===[good9.bminor Output]===
Success!

TOKEN_IDENTIFIER testfunc
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_COMMA ,
TOKEN_IDENTIFIER y
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_COMMA ,
TOKEN_IDENTIFIER z
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_IDENTIFIER r
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER b
TOKEN_COLON :
TOKEN_BOOLEAN boolean
TOKEN_SEMICOLON ;
TOKEN_CPP_COMMENT // Parens required
TOKEN_IDENTIFIER r
TOKEN_ASSIGN =
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_ADD +
TOKEN_IDENTIFIER y
TOKEN_R_PAREN )
TOKEN_DIV /
TOKEN_IDENTIFIER z
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER r
TOKEN_ASSIGN =
TOKEN_IDENTIFIER x
TOKEN_ADD +
TOKEN_L_PAREN (
TOKEN_IDENTIFIER y
TOKEN_ADD +
TOKEN_IDENTIFIER z
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER b
TOKEN_ASSIGN =
TOKEN_L_PAREN (
TOKEN_TRUE true
TOKEN_OR ||
TOKEN_FALSE false
TOKEN_R_PAREN )
TOKEN_AND &&
TOKEN_L_PAREN (
TOKEN_FALSE false
TOKEN_OR ||
TOKEN_TRUE true
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_CPP_COMMENT // Parens not required
TOKEN_IDENTIFIER r
TOKEN_ASSIGN =
TOKEN_IDENTIFIER x
TOKEN_ADD +
TOKEN_L_PAREN (
TOKEN_IDENTIFIER y
TOKEN_DIV /
TOKEN_IDENTIFIER z
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER r
TOKEN_ASSIGN =
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_ADD +
TOKEN_IDENTIFIER y
TOKEN_R_PAREN )
TOKEN_ADD +
TOKEN_IDENTIFIER z
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER b
TOKEN_ASSIGN =
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_ADD +
TOKEN_IDENTIFIER y
TOKEN_R_PAREN )
TOKEN_LESS <
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_ADD +
TOKEN_IDENTIFIER z
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER b
TOKEN_ASSIGN =
TOKEN_L_PAREN (
TOKEN_TRUE true
TOKEN_AND &&
TOKEN_FALSE false
TOKEN_R_PAREN )
TOKEN_OR ||
TOKEN_L_PAREN (
TOKEN_FALSE false
TOKEN_AND &&
TOKEN_TRUE true
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_EOF 
Parse successful


return code: 0


====Bad Tests====
===[bad1.bminor Input]===
/* A program is a not an expression at the top level */

x = 5;


===[bad1.bminor Output]===
TEST NOT PASSED

TOKEN_IDENTIFIER x
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 5
TOKEN_SEMICOLON ;
TOKEN_EOF 
Parse successful


return code: 0


===[bad10.bminor Input]===
/* Unbalanced braces */

main:function integer ( x: integer ) =
{
	if(x<10) {
              if(x!=23) {
                  print "hello";
              } else {
                  print "goodbye";
              }
        print "too few braces";
}

===[bad10.bminor Output]===
Success!

TOKEN_IDENTIFIER main
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_INTEGER integer
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_IF if
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_LESS <
TOKEN_INTEGER_LITERAL 10
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_IF if
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_NEQUAL !=
TOKEN_INTEGER_LITERAL 23
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_PRINT print
TOKEN_STRING_LITERAL hello
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_ELSE else
TOKEN_L_BRACE {
TOKEN_PRINT print
TOKEN_STRING_LITERAL goodbye
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_PRINT print
TOKEN_STRING_LITERAL too few braces
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_EOF 
parse error: syntax error


return code: 1


===[bad11.bminor Input]===
/* return return */

simplefunc: function void () = {
     x: integer = 10;
     y: integer = 20;

     return return;

}

===[bad11.bminor Output]===
Success!

TOKEN_IDENTIFIER simplefunc
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 10
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER y
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 20
TOKEN_SEMICOLON ;
TOKEN_RETURN return
TOKEN_RETURN return
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_EOF 
parse error: syntax error


return code: 1


===[bad12.bminor Input]===
/* invalid keyword usage */

simplefunc: function void () = {
     x: integer = 10;
     array: integer = 20;

     return x + array;
}

===[bad12.bminor Output]===
Success!

TOKEN_IDENTIFIER simplefunc
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 10
TOKEN_SEMICOLON ;
TOKEN_ARRAY array
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 20
TOKEN_SEMICOLON ;
TOKEN_RETURN return
TOKEN_IDENTIFIER x
TOKEN_ADD +
TOKEN_ARRAY array
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_EOF 
parse error: syntax error


return code: 1


===[bad13.bminor Input]===

/* empty array initializer */

simplefunc: function void () = {
     x: integer = 10;
     y: integer = 20;
	
     p: array [5] integer = {};
}

===[bad13.bminor Output]===
Success!

TOKEN_IDENTIFIER simplefunc
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 10
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER y
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 20
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER p
TOKEN_COLON :
TOKEN_ARRAY array
TOKEN_L_BRACKET [
TOKEN_INTEGER_LITERAL 5
TOKEN_R_BRACKET ]
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_R_BRACE }
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_EOF 
parse error: syntax error


return code: 1


===[bad14.bminor Input]===

/* Array declaration attempt */


simplefunc: function void () = {
	c7: array [x] char = {'C', 'E', 'G', "Bb"};
	d7: array [c7;] char = c7 + 1; 
}

===[bad14.bminor Output]===
Success!

TOKEN_IDENTIFIER simplefunc
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_IDENTIFIER c7
TOKEN_COLON :
TOKEN_ARRAY array
TOKEN_L_BRACKET [
TOKEN_IDENTIFIER x
TOKEN_R_BRACKET ]
TOKEN_CHARACTER char
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_CHARACTER_LITERAL 'C'
TOKEN_COMMA ,
TOKEN_CHARACTER_LITERAL 'E'
TOKEN_COMMA ,
TOKEN_CHARACTER_LITERAL 'G'
TOKEN_COMMA ,
TOKEN_STRING_LITERAL Bb
TOKEN_R_BRACE }
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER d7
TOKEN_COLON :
TOKEN_ARRAY array
TOKEN_L_BRACKET [
TOKEN_IDENTIFIER c7
TOKEN_SEMICOLON ;
TOKEN_R_BRACKET ]
TOKEN_CHARACTER char
TOKEN_ASSIGN =
TOKEN_IDENTIFIER c7
TOKEN_ADD +
TOKEN_INTEGER_LITERAL 1
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_EOF 
parse error: syntax error


return code: 1


===[bad15.bminor Input]===
/* empty file? */


===[bad15.bminor Output]===
TEST NOT PASSED

TOKEN_EOF 
Parse successful


return code: 0


===[bad2.bminor Input]===
/* A program is a not a sequence of statements */

print "hello world";
return 5;

===[bad2.bminor Output]===
TEST NOT PASSED

TOKEN_PRINT print
TOKEN_STRING_LITERAL hello world
TOKEN_SEMICOLON ;
TOKEN_RETURN return
TOKEN_INTEGER_LITERAL 5
TOKEN_SEMICOLON ;
TOKEN_EOF 
Parse successful


return code: 0


===[bad3.bminor Input]===
/* Cannot have more elses than ifs */

simplefunc: function void () = {
     x: integer = 10;
     y: integer = 20;

     if(x<y) if(y>x) else print "a"; else print "b" else print "c";
}

===[bad3.bminor Output]===
Success!

TOKEN_IDENTIFIER simplefunc
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 10
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER y
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 20
TOKEN_SEMICOLON ;
TOKEN_IF if
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_LESS <
TOKEN_IDENTIFIER y
TOKEN_R_PAREN )
TOKEN_IF if
TOKEN_L_PAREN (
TOKEN_IDENTIFIER y
TOKEN_GREATER >
TOKEN_IDENTIFIER x
TOKEN_R_PAREN )
TOKEN_ELSE else
TOKEN_PRINT print
TOKEN_STRING_LITERAL a
TOKEN_SEMICOLON ;
TOKEN_ELSE else
TOKEN_PRINT print
TOKEN_STRING_LITERAL b
TOKEN_ELSE else
TOKEN_PRINT print
TOKEN_STRING_LITERAL c
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_EOF 
parse error: syntax error


return code: 1


===[bad4.bminor Input]===
/* For loop does need to have semis even if parts are missing */

main: function void() =
{
        i: integer;
	for(i=0;) print i;
}

===[bad4.bminor Output]===
Success!

TOKEN_IDENTIFIER main
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_IDENTIFIER i
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_SEMICOLON ;
TOKEN_FOR for
TOKEN_L_PAREN (
TOKEN_IDENTIFIER i
TOKEN_ASSIGN =
TOKEN_INTEGER_LITERAL 0
TOKEN_SEMICOLON ;
TOKEN_R_PAREN )
TOKEN_PRINT print
TOKEN_IDENTIFIER i
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_EOF 
parse error: syntax error


return code: 1


===[bad5.bminor Input]===
/* Print statement must separate elemnts with a comma */

main:function void()
{
	print x y z;
}

===[bad5.bminor Output]===
Success!

TOKEN_IDENTIFIER main
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_PRINT print
TOKEN_IDENTIFIER x
TOKEN_IDENTIFIER y
TOKEN_IDENTIFIER z
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_EOF 
parse error: syntax error


return code: 1


===[bad6.bminor Input]===
/* Function parameters must separate with a comma */

main:function void( x:integer y:integer );

===[bad6.bminor Output]===
Success!

TOKEN_IDENTIFIER main
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_VOID void
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_IDENTIFIER y
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_EOF 
parse error: syntax error


return code: 1


===[bad7.bminor Input]===
/* No invalid seqeuences of operators */

main:function integer ( x:integer ) = {

        return x + * 5 * - 7;
}

===[bad7.bminor Output]===
Success!

TOKEN_IDENTIFIER main
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_INTEGER integer
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_RETURN return
TOKEN_IDENTIFIER x
TOKEN_ADD +
TOKEN_MUL *
TOKEN_INTEGER_LITERAL 5
TOKEN_MUL *
TOKEN_SUB -
TOKEN_INTEGER_LITERAL 7
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_EOF 
parse error: syntax error


return code: 1


===[bad8.bminor Input]===
/* Unbalanced parentheses */

main:function integer( x: integer ) =
{
	return (x*(x+5);
}

===[bad8.bminor Output]===
Success!

TOKEN_IDENTIFIER main
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_INTEGER integer
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_RETURN return
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_MUL *
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_ADD +
TOKEN_INTEGER_LITERAL 5
TOKEN_R_PAREN )
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_EOF 
parse error: syntax error


return code: 1


===[bad9.bminor Input]===
/* Unbalanced braces */

main:function integer ( x: integer ) =
{
	if(x<10) {
              if(x!=23) {
                  print "hello";
              } else {
                  print "goodbye";
              }
        }

    }
    print "too many braces";
}

===[bad9.bminor Output]===
Success!

TOKEN_IDENTIFIER main
TOKEN_COLON :
TOKEN_FUNCTION function
TOKEN_INTEGER integer
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_INTEGER integer
TOKEN_R_PAREN )
TOKEN_ASSIGN =
TOKEN_L_BRACE {
TOKEN_IF if
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_LESS <
TOKEN_INTEGER_LITERAL 10
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_IF if
TOKEN_L_PAREN (
TOKEN_IDENTIFIER x
TOKEN_NEQUAL !=
TOKEN_INTEGER_LITERAL 23
TOKEN_R_PAREN )
TOKEN_L_BRACE {
TOKEN_PRINT print
TOKEN_STRING_LITERAL hello
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_ELSE else
TOKEN_L_BRACE {
TOKEN_PRINT print
TOKEN_STRING_LITERAL goodbye
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_R_BRACE }
TOKEN_R_BRACE }
TOKEN_PRINT print
TOKEN_STRING_LITERAL too many braces
TOKEN_SEMICOLON ;
TOKEN_R_BRACE }
TOKEN_EOF 
parse error: syntax error


return code: 1


===== SUMMARIZED PARSER RESULTS =====
{
  "student_tests": {
    "Good": {
      "correct": 18,
      "incorrect": 0
    },
    "Bad": {
      "correct": 21,
      "incorrect": 0
    }
  },
  "hidden_tests": {
    "Good": {
      "correct": 14,
      "incorrect": 1
    },
    "Bad": {
      "correct": 12,
      "incorrect": 3
    }
  }
}

Parser Project Grade
-------------------

General Structure: 22/25
---------------------------------
Overall structure is correct. Scanner 
tokens should not print out during parsing

Eliminating Ambiguities: 10/10
--------------------------------------

Student Tests: 20/20
---------------------------
Passes all your tests.

Hidden Tests: 32/35
---------------------------
Fails 3 hidden tests, see above. Remember
the distinction between statements and declarations

Code Style: 10/10
------------------------
grammar is well organized

Total: 94/100
------------------------------------------
