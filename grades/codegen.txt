=====STUDENT TESTS=====
====Good Tests====
===[good0.bminor Input]===
main:function void ()=
{
	x:integer=5;
	print x;
}
===[good0.bminor Output]===
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $40, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $5, %rbx
	MOVQ %rbx, -8(%rbp)
	MOVQ -8(%rbp), %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_integer
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET

5

return code: 1


===[good1.bminor Input]===
main:function integer ()=
{
	x:integer = 8;
	y:integer = 2;
	x = x + y;
	return x;
}

===[good1.bminor Output]===
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $40, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $8, %rbx
	MOVQ %rbx, -8(%rbp)
	MOVQ $2, %rbx
	MOVQ %rbx, -16(%rbp)
	MOVQ -8(%rbp), %rbx
	MOVQ -16(%rbp), %r10
	ADDQ %rbx, %r10
	MOVQ %r10, -8(%rbp)
	MOVQ -8(%rbp), %rbx
	MOV %rbx, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET



return code: 10


===[good10.bminor Input]===
// tests character printing
i:char= 'i';
main:function integer () =
{
	n:char ='n';
	print 'h', 'd', i; 
	return 0;
}
===[good10.bminor Output]===
.data
i:	.quad 105
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $40, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $110, %rbx
	MOVQ %rbx, -8(%rbp)
	MOVQ $104, %rbx
	MOVQ $100, %r10
	MOVQ i, %r11
	MOVQ %rbx, %rdi
	MOVQ %r10, %rsi
	MOVQ %r11, %rdx
	PUSHQ %r10
	PUSHQ %r11
	CALL print_character
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ $100, %rbx
	MOVQ i, %r10
	MOVQ %rbx, %rdi
	MOVQ %r10, %rsi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_character
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ i, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_character
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ $0, %rbx
	MOV %rbx, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET

hdi

return code: 0


===[good11.bminor Input]===
// Uses a complex expression
x:integer=5;
main:function integer () =
{
	y:integer = 2;
	return 10*y - x*4;
}
===[good11.bminor Output]===
.data
x:	.quad 5
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $40, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $2, %rbx
	MOVQ %rbx, -8(%rbp)
	MOVQ $10, %rbx
	MOVQ -8(%rbp), %r10
	MOVQ %rbx, %rax
	IMULQ %r10
	MOVQ %rax, %r10
	MOVQ x, %rbx
	MOVQ $4, %r11
	MOVQ %rbx, %rax
	IMULQ %r11
	MOVQ %rax, %r11
	SUBQ %r11, %r10
	MOV %r11, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET



return code: 20


===[good12.bminor Input]===
/*global decls */
x: integer = 1;
y: char = '\n';
w: boolean = true;
z: string = "compilers";
b: array [3] integer = {1,2,3};

main: function integer () = {
    return 0;
}
===[good12.bminor Output]===
.data
x:	.quad 1
.data
y:	.quad 110
.data
w:	.quad 1
.data
z:	.string "compilers"
.data
.L0:
	.quad 1
	.quad 2
	.quad 3
.globl b
b:
	.quad .L0
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $40, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $0, %rbx
	MOV %rbx, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET



return code: 0


===[good13.bminor Input]===
// decl global arrays
b: array [3] integer = {1,2,3};
main: function integer () = {
    return b[1];
}
===[good13.bminor Output]===
.data
.L0:
	.quad 1
	.quad 2
	.quad 3
.globl b
b:
	.quad .L0
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $40, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ b, %rbx
	MOVQ $1, %r10
	MOVQ $8, %rax
	IMULQ %r10
	MOVQ %rax, %r11
	ADDQ %rbx, %r11
	MOVQ (%r11), %rbx
	MOV %rbx, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET



return code: 2


===[good14.bminor Input]===
 //function calls with no parameters and with parameters
x:integer=5;
fxnCall:function integer() =
{
	return x*4;
}

fxnCall2:function integer(z:integer) =
{
    return z*2;
}

main:function integer () =
{
	y:integer = 2;
    y = y+ fxnCall()+fxnCall2(14);
	return y;
}
===[good14.bminor Output]===
.data
x:	.quad 5
.text
.globl fxnCall
fxnCall:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $40, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ x, %rbx
	MOVQ $4, %r10
	MOVQ %rbx, %rax
	IMULQ %r10
	MOVQ %rax, %r10
	MOV %r10, %rax
	JMP .fxnCall_epilogue
.fxnCall_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET
.text
.globl fxnCall2
fxnCall2:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	PUSHQ %rdi
	SUBQ $40, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ 8(%rbp), %rbx
	MOVQ $2, %r10
	MOVQ %rbx, %rax
	IMULQ %r10
	MOVQ %rax, %r10
	MOV %r10, %rax
	JMP .fxnCall2_epilogue
.fxnCall2_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $40, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $2, %rbx
	MOVQ %rbx, -8(%rbp)
	MOVQ -8(%rbp), %rbx
	PUSHQ %r10
	PUSHQ %r11
	CALL fxnCall
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %r10
	MOVQ $14, %r11
	MOVQ %r11, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL fxnCall2
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %r11
	ADDQ %r10, %r11
	ADDQ %rbx, %r11
	MOVQ %r11, -8(%rbp)
	MOVQ -8(%rbp), %rbx
	MOV %rbx, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET



return code: 82


===[good15.bminor Input]===
// assign array
b: array [3] integer = {1,2,3};
main: function integer () = {
    x: integer = b[1];
    print x;
    return 0;
}
===[good15.bminor Output]===
.data
.L0:
	.quad 1
	.quad 2
	.quad 3
.globl b
b:
	.quad .L0
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $40, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ b, %rbx
	MOVQ $1, %r10
	MOVQ $8, %rax
	IMULQ %r10
	MOVQ %rax, %r11
	ADDQ %rbx, %r11
	MOVQ (%r11), %rbx
	MOVQ %rbx, -8(%rbp)
	MOVQ -8(%rbp), %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_integer
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ $0, %rbx
	MOV %rbx, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET

2

return code: 0


===[good16.bminor Input]===
// tests strings/string assignments and printing 

main:function integer () =
{
	c:char = 'd';
    str:string = "hello";
	print str;
	return 0;
}
===[good16.bminor Output]===
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $40, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $100, %rbx
	MOVQ %rbx, -8(%rbp)
.data
.L0:
	.string "hello"
.text
	LEAQ .L0, %rbx
	MOVQ %rbx, -16(%rbp)
	MOVQ -16(%rbp), %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ $0, %rbx
	MOV %rbx, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET

hello

return code: 0


===[good17.bminor Input]===
// tests comparisions/if statements
x:integer = 5;
main: function integer () =
{
	y:integer = 10;
	z:integer = 5;
	if(x >= z)
		print "should be printed\n";
	else
	{
		print "shouldn't be printed\n";
	}

	if(y > x )
	{
		print "should be printed\n";
	}
	else
	{
		print "shouldn't be printed\n";
	}
	if(z == x )
	{
		print "should be printed\n";
	}
	else
		print "shouldn't be printed\n";
	
	if(x <= y )
	{
		print "should be printed\n";
	}
	else
	{
		print "shouldn't be printed\n";
	}
	if(x != y )
	{
		print "should be printed\n";
	}
	else
	{
		print "shouldn't be printed\n";
	}


	//switched now (statement should be false)
	if(z < x )
	{
		print "shouldn't be printed\n";
	}
	else
	{
		print "should be printed\n";
	}

	if(y < x )
	{
		print "shouldn't be printed\n";
	}
	else
	{
		print "should be printed\n";
	}
	if(z != x )
	{
		print "shouldn't be printed\n";
	}
	else
	{
		print "should be printed\n";
	}
	
	if(y <= x )
	{
		print "shouldn't be printed\n";
	}
	else
	{
		print "should be printed\n";
	}
	if(y == x )
	{
		print "shouldn't be printed\n";
	}
	else
	{
		print "should be printed\n";
	}

    return 0;
}
===[good17.bminor Output]===
.data
x:	.quad 5
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $40, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $10, %rbx
	MOVQ %rbx, -8(%rbp)
	MOVQ $5, %rbx
	MOVQ %rbx, -16(%rbp)
	MOVQ x, %rbx
	MOVQ -16(%rbp), %r10
	CMPQ %r10, %rbx
	JGE .L2
	MOVQ $0, %rbx
	JMP .L3
.L2:
	MOVQ $1, %rbx
.L3:
	CMP $0, %rbx
	JE .L0
.data
.L4:
	.string "should be printed\n"
.text
	LEAQ .L4, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	JMP .L1
.L0:
.data
.L5:
	.string "shouldn't be printed\n"
.text
	LEAQ .L5, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.L1:
	MOVQ -8(%rbp), %rbx
	MOVQ x, %r10
	CMPQ %r10, %rbx
	JG .L8
	MOVQ $0, %rbx
	JMP .L9
.L8:
	MOVQ $1, %rbx
.L9:
	CMP $0, %rbx
	JE .L6
.data
.L10:
	.string "should be printed\n"
.text
	LEAQ .L10, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	JMP .L7
.L6:
.data
.L11:
	.string "shouldn't be printed\n"
.text
	LEAQ .L11, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.L7:
	MOVQ -16(%rbp), %rbx
	MOVQ x, %r10
	CMPQ %r10, %rbx
	JE .L14
	MOVQ $0, %rbx
	JMP .L15
.L14:
	MOVQ $1, %rbx
.L15:
	CMP $0, %rbx
	JE .L12
.data
.L16:
	.string "should be printed\n"
.text
	LEAQ .L16, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	JMP .L13
.L12:
.data
.L17:
	.string "shouldn't be printed\n"
.text
	LEAQ .L17, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.L13:
	MOVQ x, %rbx
	MOVQ -8(%rbp), %r10
	CMPQ %r10, %rbx
	JLE .L20
	MOVQ $0, %rbx
	JMP .L21
.L20:
	MOVQ $1, %rbx
.L21:
	CMP $0, %rbx
	JE .L18
.data
.L22:
	.string "should be printed\n"
.text
	LEAQ .L22, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	JMP .L19
.L18:
.data
.L23:
	.string "shouldn't be printed\n"
.text
	LEAQ .L23, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.L19:
	MOVQ x, %rbx
	MOVQ -8(%rbp), %r10
	CMPQ %r10, %rbx
	JNE .L26
	MOVQ $0, %rbx
	JMP .L27
.L26:
	MOVQ $1, %rbx
.L27:
	CMP $0, %rbx
	JE .L24
.data
.L28:
	.string "should be printed\n"
.text
	LEAQ .L28, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	JMP .L25
.L24:
.data
.L29:
	.string "shouldn't be printed\n"
.text
	LEAQ .L29, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.L25:
	MOVQ -16(%rbp), %rbx
	MOVQ x, %r10
	CMPQ %r10, %rbx
	JL .L32
	MOVQ $0, %rbx
	JMP .L33
.L32:
	MOVQ $1, %rbx
.L33:
	CMP $0, %rbx
	JE .L30
.data
.L34:
	.string "shouldn't be printed\n"
.text
	LEAQ .L34, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	JMP .L31
.L30:
.data
.L35:
	.string "should be printed\n"
.text
	LEAQ .L35, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.L31:
	MOVQ -8(%rbp), %rbx
	MOVQ x, %r10
	CMPQ %r10, %rbx
	JL .L38
	MOVQ $0, %rbx
	JMP .L39
.L38:
	MOVQ $1, %rbx
.L39:
	CMP $0, %rbx
	JE .L36
.data
.L40:
	.string "shouldn't be printed\n"
.text
	LEAQ .L40, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	JMP .L37
.L36:
.data
.L41:
	.string "should be printed\n"
.text
	LEAQ .L41, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.L37:
	MOVQ -16(%rbp), %rbx
	MOVQ x, %r10
	CMPQ %r10, %rbx
	JNE .L44
	MOVQ $0, %rbx
	JMP .L45
.L44:
	MOVQ $1, %rbx
.L45:
	CMP $0, %rbx
	JE .L42
.data
.L46:
	.string "shouldn't be printed\n"
.text
	LEAQ .L46, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	JMP .L43
.L42:
.data
.L47:
	.string "should be printed\n"
.text
	LEAQ .L47, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.L43:
	MOVQ -8(%rbp), %rbx
	MOVQ x, %r10
	CMPQ %r10, %rbx
	JLE .L50
	MOVQ $0, %rbx
	JMP .L51
.L50:
	MOVQ $1, %rbx
.L51:
	CMP $0, %rbx
	JE .L48
.data
.L52:
	.string "shouldn't be printed\n"
.text
	LEAQ .L52, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	JMP .L49
.L48:
.data
.L53:
	.string "should be printed\n"
.text
	LEAQ .L53, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.L49:
	MOVQ -8(%rbp), %rbx
	MOVQ x, %r10
	CMPQ %r10, %rbx
	JE .L56
	MOVQ $0, %rbx
	JMP .L57
.L56:
	MOVQ $1, %rbx
.L57:
	CMP $0, %rbx
	JE .L54
.data
.L58:
	.string "shouldn't be printed\n"
.text
	LEAQ .L58, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	JMP .L55
.L54:
.data
.L59:
	.string "should be printed\n"
.text
	LEAQ .L59, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.L55:
	MOVQ $0, %rbx
	MOV %rbx, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET

should be printed
should be printed
should be printed
should be printed
should be printed
should be printed
should be printed
should be printed
should be printed
should be printed


return code: 0


===[good18.bminor Input]===
// tests post increment
x:integer = 1;
main: function integer () =
{
	y:integer = x++;
    return y;
}
===[good18.bminor Output]===
.data
x:	.quad 1
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $40, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ x, %rbx
	MOVQ %rbx, %rax
	ADDQ $1, %rax
	MOVQ %rax, %rbx
	MOVQ %rbx, -8(%rbp)
	MOVQ -8(%rbp), %rbx
	MOV %rbx, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET



return code: 2


===[good19.bminor Input]===
// tests exp

main:function integer () =
{
	x:integer = 2;
    y:integer = 3;
    return x^y;
}
===[good19.bminor Output]===
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $40, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $2, %rbx
	MOVQ %rbx, -8(%rbp)
	MOVQ $3, %rbx
	MOVQ %rbx, -16(%rbp)
	MOVQ -8(%rbp), %rbx
	MOVQ -16(%rbp), %r10
	MOVQ %rbx, %rdi
	MOVQ %r10, %rsi
	CALL integer_power
	MOVQ %rax, %r10
	MOV %r10, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET



return code: 8


===[good2.bminor Input]===
main:function integer ()=
{
	return 10;
}
===[good2.bminor Output]===
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $40, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $10, %rbx
	MOV %rbx, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET



return code: 10


===[good20.bminor Input]===
//test logical operator

main:function integer () =
{
	x:boolean = true;
    y:boolean = false;
    z:boolean = x&&y;
    print z;
    return 0;
}
===[good20.bminor Output]===
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $40, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $1, %rbx
	MOVQ %rbx, -8(%rbp)
	MOVQ $0, %rbx
	MOVQ %rbx, -16(%rbp)
	MOVQ -8(%rbp), %rbx
	MOVQ -16(%rbp), %r10
	ANDQ %rbx, %r10
	MOVQ %r10, -24(%rbp)
	MOVQ -24(%rbp), %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_boolean
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ $0, %rbx
	MOV %rbx, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET

false

return code: 0


===[good21.bminor Input]===
//test strings with escape characters
main:function integer () =
{
	print "Hello World\nHello\tWorld";
    return 0;
}
===[good21.bminor Output]===
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $40, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
.data
.L0:
	.string "Hello World\nHello\tWorld"
.text
	LEAQ .L0, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ $0, %rbx
	MOV %rbx, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET

Hello World
Hello	World

return code: 0


===[good3.bminor Input]===
// tests multiplication
main:function integer ()=
{
	return 5 * 2;
}
===[good3.bminor Output]===
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $40, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $5, %rbx
	MOVQ $2, %r10
	MOVQ %rbx, %rax
	IMULQ %r10
	MOVQ %rax, %r10
	MOV %r10, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET



return code: 10


===[good4.bminor Input]===
// tests division
main:function integer ()=
{
	return 20 / 2;
}
===[good4.bminor Output]===
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $40, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $20, %rbx
	MOVQ $2, %r10
	MOVQ %rbx, %rax
	CQO
	IDIVQ %r10
	MOVQ %rax, %r10
	MOV %r10, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET



return code: 10


===[good5.bminor Input]===
// Adds a local variable
x:integer=5;
main:function integer ()=
{
y:integer = 2;
	return x * y;
}
===[good5.bminor Output]===
.data
x:	.quad 5
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $40, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $2, %rbx
	MOVQ %rbx, -8(%rbp)
	MOVQ x, %rbx
	MOVQ -8(%rbp), %r10
	MOVQ %rbx, %rax
	IMULQ %r10
	MOVQ %rax, %r10
	MOV %r10, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET



return code: 10


===[good6.bminor Input]===
 //function call
x:integer=5;
fxnCall:function integer() =
{
	return x*4;
}
main:function integer () =
{
	y:integer = 2;
    y = y+ fxnCall();
	return y;
}
===[good6.bminor Output]===
.data
x:	.quad 5
.text
.globl fxnCall
fxnCall:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $40, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ x, %rbx
	MOVQ $4, %r10
	MOVQ %rbx, %rax
	IMULQ %r10
	MOVQ %rax, %r10
	MOV %r10, %rax
	JMP .fxnCall_epilogue
.fxnCall_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $40, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $2, %rbx
	MOVQ %rbx, -8(%rbp)
	MOVQ -8(%rbp), %rbx
	PUSHQ %r10
	PUSHQ %r11
	CALL fxnCall
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %r10
	ADDQ %rbx, %r10
	MOVQ %r10, -8(%rbp)
	MOVQ -8(%rbp), %rbx
	MOV %rbx, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET



return code: 22


===[good7.bminor Input]===
// tests if statements 

main:function integer () =
{
	x:integer = 5;
	if(false)
		x=15;
	else
		x=10;
	return x;
	
}
===[good7.bminor Output]===
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $40, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $5, %rbx
	MOVQ %rbx, -8(%rbp)
	MOVQ $0, %rbx
	CMP $0, %rbx
	JE .L0
	MOVQ $15, %rbx
	MOVQ %rbx, -8(%rbp)
	JMP .L1
.L0:
	MOVQ $10, %rbx
	MOVQ %rbx, -8(%rbp)
.L1:
	MOVQ -8(%rbp), %rbx
	MOV %rbx, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET



return code: 10


===[good8.bminor Input]===
// tests for comparison
main: function integer () =
{
	x: integer = 0;
	y: integer = 1;
	if (x > y)
	{
		return 0;
	}else{
		return 1;
	}
}
===[good8.bminor Output]===
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $40, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $0, %rbx
	MOVQ %rbx, -8(%rbp)
	MOVQ $1, %rbx
	MOVQ %rbx, -16(%rbp)
	MOVQ -8(%rbp), %rbx
	MOVQ -16(%rbp), %r10
	CMPQ %r10, %rbx
	JG .L2
	MOVQ $0, %rbx
	JMP .L3
.L2:
	MOVQ $1, %rbx
.L3:
	CMP $0, %rbx
	JE .L0
	MOVQ $0, %rbx
	MOV %rbx, %rax
	JMP .main_epilogue
	JMP .L1
.L0:
	MOVQ $1, %rbx
	MOV %rbx, %rax
	JMP .main_epilogue
.L1:
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET



return code: 1


===[good9.bminor Input]===
// tests strings/string assignments and printing 
str:string = "hello";
main:function integer () =
{
	c:char = 'd';
	print "Hello";
	return 0;
}
===[good9.bminor Output]===
.data
str:	.string "hello"
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $40, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $100, %rbx
	MOVQ %rbx, -8(%rbp)
.data
.L0:
	.string "Hello"
.text
	LEAQ .L0, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ $0, %rbx
	MOV %rbx, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET

Hello

return code: 0


====Bad Tests====
=====HIDDEN TESTS=====
====Good Tests====
===[good1.bminor Input]===
strlen: function integer(s: string);
f: function integer(i: integer);

main: function integer () = {
	if (f(strlen("hi")) > strlen("there")) {print "no\n";}
	if (f(f(strlen("hi"))) > strlen("there")) print "ok\n";

	return 0;
}

f: function integer(i: integer) = {
	return i*2;
}

===[good1.bminor Output]===
.text
.globl strlen
.text
.globl f
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $40, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
.data
.L2:
	.string "hi"
.text
	LEAQ .L2, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL strlen
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL f
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.data
.L3:
	.string "there"
.text
	LEAQ .L3, %r10
	MOVQ %r10, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL strlen
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %r10
	CMPQ %r10, %rbx
	JG .L4
	MOVQ $0, %rbx
	JMP .L5
.L4:
	MOVQ $1, %rbx
.L5:
	CMP $0, %rbx
	JE .L0
.data
.L6:
	.string "no\n"
.text
	LEAQ .L6, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	JMP .L1
.L0:
.L1:
.data
.L9:
	.string "hi"
.text
	LEAQ .L9, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL strlen
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL f
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL f
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.data
.L10:
	.string "there"
.text
	LEAQ .L10, %r10
	MOVQ %r10, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL strlen
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %r10
	CMPQ %r10, %rbx
	JG .L11
	MOVQ $0, %rbx
	JMP .L12
.L11:
	MOVQ $1, %rbx
.L12:
	CMP $0, %rbx
	JE .L7
.data
.L13:
	.string "ok\n"
.text
	LEAQ .L13, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	JMP .L8
.L7:
.L8:
	MOVQ $0, %rbx
	MOV %rbx, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET
.text
.globl f
f:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	PUSHQ %rdi
	SUBQ $40, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ 24(%rbp), %rbx
	MOVQ $2, %r10
	MOVQ %rbx, %rax
	IMULQ %r10
	MOVQ %rax, %r10
	MOV %r10, %rax
	JMP .f_epilogue
.f_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET

ok


return code: 0


===[good11.bminor Input]===
main: function integer () = {
	x: integer = 20;
	y: integer = x;
	{
		x: integer = 10;
		y = y + x;
	}

	{
		{
			y = y + x;
			x: integer = 2;
			y = y + x;
		}
		y = y + x;
		x: integer = 3;
		y = y + x;
	}
	return y + x;
}

===[good11.bminor Output]===
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $40, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $20, %rbx
	MOVQ %rbx, -8(%rbp)
	MOVQ -8(%rbp), %rbx
	MOVQ %rbx, -16(%rbp)
	MOVQ $10, %rbx
	MOVQ %rbx, -24(%rbp)
	MOVQ -16(%rbp), %rbx
	MOVQ -24(%rbp), %r10
	ADDQ %rbx, %r10
	MOVQ %r10, -16(%rbp)
	MOVQ -16(%rbp), %rbx
	MOVQ -8(%rbp), %r10
	ADDQ %rbx, %r10
	MOVQ %r10, -16(%rbp)
	MOVQ $2, %rbx
	MOVQ %rbx, -32(%rbp)
	MOVQ -16(%rbp), %rbx
	MOVQ -32(%rbp), %r10
	ADDQ %rbx, %r10
	MOVQ %r10, -16(%rbp)
	MOVQ -16(%rbp), %rbx
	MOVQ -8(%rbp), %r10
	ADDQ %rbx, %r10
	MOVQ %r10, -16(%rbp)
	MOVQ $3, %rbx
	MOVQ %rbx, -40(%rbp)
	MOVQ -16(%rbp), %rbx
	MOVQ -40(%rbp), %r10
	ADDQ %rbx, %r10
	MOVQ %r10, -16(%rbp)
	MOVQ -16(%rbp), %rbx
	MOVQ -8(%rbp), %r10
	ADDQ %rbx, %r10
	MOV %r10, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET



return code: 95


===[good8.bminor Input]===
abs: function integer(n: integer);

digits: array [6] integer = {
	14,
	8,
	6168,
	42,
	0,
	74546
};

main:function integer () = {
	digits[4] = -468;
	i: integer = 0;
	for (; abs(digits[i]) == digits[i];) {
		print digits[i];
		i = i + 1;
		print ' ';
	}
	print '\n';

	return 0;
}

===[good8.bminor Output]===
TEST NOT PASSED - CODEGEN ERROR



return code: 1


===[good13.bminor Input]===
foo_epilogue: function integer () = {
	return 2;
}

foo: function integer ();

main: function integer () = {
	return foo() * 11;
}

main_epilogue: function integer () = {
	return foo_epilogue() + 3;
}

foo: function integer () = {
	return main_epilogue() - 1;
}

===[good13.bminor Output]===
.text
.globl foo_epilogue
foo_epilogue:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $40, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $2, %rbx
	MOV %rbx, %rax
	JMP .foo_epilogue_epilogue
.foo_epilogue_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET
.text
.globl foo
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $40, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	PUSHQ %r10
	PUSHQ %r11
	CALL foo
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ $11, %r10
	MOVQ %rbx, %rax
	IMULQ %r10
	MOVQ %rax, %r10
	MOV %r10, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET
.text
.globl main_epilogue
main_epilogue:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $40, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	PUSHQ %r10
	PUSHQ %r11
	CALL foo_epilogue
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ $3, %r10
	ADDQ %rbx, %r10
	MOV %r10, %rax
	JMP .main_epilogue_epilogue
.main_epilogue_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET
.text
.globl foo
foo:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $40, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	PUSHQ %r10
	PUSHQ %r11
	CALL main_epilogue
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ $1, %r10
	SUBQ %r10, %rbx
	MOV %r10, %rax
	JMP .foo_epilogue
.foo_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET



return code: 11


===[good12.bminor Input]===
main: function integer () = {
	return 4 + 9 / (-2 - (-5)) + (((2 + 1) * 4) - 1) % 3 * 7 - 8;
}

===[good12.bminor Output]===
TEST NOT PASSED - CODEGEN ERROR

type error: invalid expression kind


return code: 1


===[good15.bminor Input]===
// https://piazza.com/class/jziupd2lzpm7cy?cid=179

strdup: function string (s: string);

main: function integer () = {
	a: string = "sssss";
	b: string = strdup(a);
	if (a==b) return 22; else return 11;
}

===[good15.bminor Output]===
.text
.globl strdup
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $40, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
.data
.L0:
	.string "sssss"
.text
	LEAQ .L0, %rbx
	MOVQ %rbx, -8(%rbp)
	MOVQ -8(%rbp), %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL strdup
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ %rbx, -16(%rbp)
	MOVQ -8(%rbp), %rbx
	MOVQ -16(%rbp), %r10
	CMPQ %r10, %rbx
	JE .L3
	MOVQ $0, %rbx
	JMP .L4
.L3:
	MOVQ $1, %rbx
.L4:
	CMP $0, %rbx
	JE .L1
	MOVQ $22, %rbx
	MOV %rbx, %rax
	JMP .main_epilogue
	JMP .L2
.L1:
	MOVQ $11, %rbx
	MOV %rbx, %rax
	JMP .main_epilogue
.L2:
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET



return code: 11


===[good17.bminor Input]===
a1: integer;
a2: integer = 111;
a3: boolean = false;

A: function integer() = {
	if (a3) return a1 * a2;
	a2: integer = 3;
	if (!!!a3) return a1 + a2;
	return 0;
}

main: function integer() = { return A(); }

===[good17.bminor Output]===
TEST NOT PASSED - CODEGEN ERROR



return code: -11


===[good18.bminor Input]===
b1: integer = 3;
b2: integer = 6;
b3: integer = 9;

B: function integer(b3: integer, b4: integer) = {
	print b1 * b2 + b3 % b4;
	print '\n';
	b3 = 37;
	return b3;
}

main: function integer () = {
	print B(5, 3);
	return b3;
}

===[good18.bminor Output]===
TEST NOT PASSED - CODEGEN ERROR



return code: -11


===[good4.bminor Input]===
collatz: function integer(n: integer, acc: integer) = {
	print n, " ", acc, "\n";
	if (n == 1) return acc;

	if (n % 2 == 0) return collatz(n/2, acc + 1);
	else return collatz(3*n + 1, acc + 1);
}

main:function integer ()=
{
	return collatz(27, 0);
}

===[good4.bminor Output]===
TEST NOT PASSED - CODEGEN ERROR

resolve error: collatz is not defined
resolve error: collatz is not defined


return code: 1


===[good20.bminor Input]===
D: function integer() = {
	d1: integer = 5;
	d2: integer = d1 + 1; //6
	{
		d3: integer = 9;
		d2: integer = d3 + d1 - 3; //11
		d4: integer = -1;
		d2 = d2 + d3; //20
		print d2 - d4, "\n";
	}
	d4: integer = 16;
	print d2 - d4, '\n';
	{
		d4: integer = -2;
		d3: integer = 1000;
		print d3 + 10;
		print "\n";
		print d4;
		print '\n';
	}
	print d4;
	return 3;
}

main: function integer () = {
	return D();
}

===[good20.bminor Output]===
.text
.globl D
D:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $40, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $5, %rbx
	MOVQ %rbx, -8(%rbp)
	MOVQ -8(%rbp), %rbx
	MOVQ $1, %r10
	ADDQ %rbx, %r10
	MOVQ %r10, -16(%rbp)
	MOVQ $9, %rbx
	MOVQ %rbx, -24(%rbp)
	MOVQ -24(%rbp), %rbx
	MOVQ -8(%rbp), %r10
	MOVQ $3, %r11
	SUBQ %r11, %r10
	ADDQ %rbx, %r11
	MOVQ %r11, -32(%rbp)
	MOVQ %rbx, -40(%rbp)
	MOVQ -32(%rbp), %rbx
	MOVQ -24(%rbp), %r10
	ADDQ %rbx, %r10
	MOVQ %r10, -32(%rbp)
	MOVQ -32(%rbp), %rbx
	MOVQ -40(%rbp), %r10
	SUBQ %r10, %rbx
.data
.L0:
	.string "\n"
.text
	LEAQ .L0, %rbx
	MOVQ %r10, %rdi
	MOVQ %rbx, %rsi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_integer
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.data
.L1:
	.string "\n"
.text
	LEAQ .L1, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ $16, %rbx
	MOVQ %rbx, -48(%rbp)
	MOVQ -16(%rbp), %rbx
	MOVQ -48(%rbp), %r10
	SUBQ %r10, %rbx
	MOVQ $110, %rbx
	MOVQ %r10, %rdi
	MOVQ %rbx, %rsi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_integer
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ $110, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_character
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ %rbx, -56(%rbp)
	MOVQ $1000, %rbx
	MOVQ %rbx, -64(%rbp)
	MOVQ -64(%rbp), %rbx
	MOVQ $10, %r10
	ADDQ %rbx, %r10
	MOVQ %r10, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_integer
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.data
.L2:
	.string "\n"
.text
	LEAQ .L2, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ -56(%rbp), %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_integer
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ $110, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_character
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ -48(%rbp), %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_integer
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ $3, %rbx
	MOV %rbx, %rax
	JMP .D_epilogue
.D_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $40, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	PUSHQ %r10
	PUSHQ %r11
	CALL D
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOV %rbx, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET

9
16n1010
110n16

return code: 3


===[good3.bminor Input]===
T: array [8] integer = {2, 1, 1, 2, 1, 2, 0, 3};

main:function integer ()=
{
	i: integer = 0;
        for (;;) {
		if (T[i] == 0) return T[5] + 10;
		else if (T[i] == 1) i++;
		else if (T[i] == 2) T[i++]--;
		else return 1;
	}

	return 0;
}

===[good3.bminor Output]===
TEST NOT PASSED - CODEGEN ERROR



return code: -11


===[good5.bminor Input]===
A: function boolean(x: integer, y: integer);
B: function integer(x: char);
C: function char(a: string);

main: function integer() = {
	if (A(B('d') - 1, 10)) {
		x: integer = 3;
		return 2 * B('!') + x;
	}
	return B(C("hello")) % 3;
}

A: function boolean(x: integer, y: integer) = {
	return x == y;
}

B: function integer(c: char) = {
	if (c == '!')
		return 10;
	else {return 11;}
}

C: function char(a: string) = {
	return '!';
}

===[good5.bminor Output]===
TEST NOT PASSED - CODEGEN ERROR



return code: 1


===[good6.bminor Input]===
f: function boolean(b: boolean) = {
	return !b;
}

x: integer = -4;

main:function integer ()=
{
	y: integer = 10;
	if (f(f(f(f(f(x <= y)))))) return 1;
	else if (x < y - x*y) {
		return 4;
	} else return 2;
}

===[good6.bminor Output]===
.text
.globl f
f:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	PUSHQ %rdi
	SUBQ $40, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ 8(%rbp), %rbx
	NOTQ %rbx
	MOV %rbx, %rax
	JMP .f_epilogue
.f_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET
.data
x:	.quad 0
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $40, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $10, %rbx
	MOVQ %rbx, -8(%rbp)
	MOVQ x, %rbx
	MOVQ -8(%rbp), %r10
	CMPQ %r10, %rbx
	JLE .L2
	MOVQ $0, %rbx
	JMP .L3
.L2:
	MOVQ $1, %rbx
.L3:
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL f
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL f
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL f
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL f
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL f
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	CMP $0, %rbx
	JE .L0
	MOVQ $1, %rbx
	MOV %rbx, %rax
	JMP .main_epilogue
	JMP .L1
.L0:
	MOVQ x, %rbx
	MOVQ -8(%rbp), %r10
	MOVQ x, %r11
	MOVQ -8(%rbp), %r12
	MOVQ %r11, %rax
	IMULQ %r12
	MOVQ %rax, %r12
	SUBQ %r12, %r10
	CMPQ %r12, %rbx
	JL .L6
	MOVQ $0, %rbx
	JMP .L7
.L6:
	MOVQ $1, %rbx
.L7:
	CMP $0, %rbx
	JE .L4
	MOVQ $4, %rbx
	MOV %rbx, %rax
	JMP .main_epilogue
	JMP .L5
.L4:
	MOVQ $2, %rbx
	MOV %rbx, %rax
	JMP .main_epilogue
.L5:
.L1:
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET



return code: 1


===[good7.bminor Input]===
/*
f: function void (i: integer) = {
	N: integer;
	for (N = 0; i > 0; i--) {
		print N;
		N = N + 1;
	}
}

main:function integer () = {
	N: integer = 6;
	for (;;N--) {
		f(N);
		print '\n';
		if (N == 0) return 0;
	}

	return 1;
}
*/

infinite loop

===[good7.bminor Output]===
TEST NOT PASSED - CODEGEN ERROR

parse error: syntax error


return code: 1


===[good9.bminor Input]===
a: array[4] integer;
main: function integer() = {
	a[2] = 60;
	return a[2] + a[2] / 20 * 3 - a[1];
}

===[good9.bminor Output]===
TEST NOT PASSED - CODEGEN ERROR



return code: -11


===[good2.bminor Input]===


X: array [4] integer = {11, 30, 22, 0};

main: function integer () = {
	i: integer;
	for (i = 0; X[i] != 0; i++)
		print X[i], ' ', X[i] % 3, '\n';

	return 0;
}

===[good2.bminor Output]===
TEST NOT PASSED - CODEGEN ERROR



return code: 1


===[good19.bminor Input]===
c1: integer = -1;
c3: integer = 100;

d1: integer = 1;
d2: integer = 2;

C: function integer(c1: integer, c2: integer) = {
	c3: integer = 11;
	c4: integer = 12;
	c5: integer = 13;
	return c1 + c2 + c3 + c4;
}

D: function integer(d1: integer, d2: integer) = {
	d3: integer = -3;
	d4: integer = 4;
	d5: integer = 5;
	return d1 + d2 + d3 - d4;
}

main: function integer() = {
	f: integer = D(6, 7);
	return C(1, 2);
}

===[good19.bminor Output]===
.data
c1:	.quad 0
.data
c3:	.quad 100
.data
d1:	.quad 1
.data
d2:	.quad 2
.text
.globl C
C:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	PUSHQ %rdi
	PUSHQ %rsi
	SUBQ $40, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $11, %rbx
	MOVQ %rbx, -8(%rbp)
	MOVQ $12, %rbx
	MOVQ %rbx, -16(%rbp)
	MOVQ $13, %rbx
	MOVQ %rbx, -24(%rbp)
	MOVQ 8(%rbp), %rbx
	MOVQ 16(%rbp), %r10
	MOVQ -8(%rbp), %r11
	MOVQ -16(%rbp), %r12
	ADDQ %r11, %r12
	ADDQ %r10, %r12
	ADDQ %rbx, %r12
	MOV %r12, %rax
	JMP .C_epilogue
.C_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET
.text
.globl D
D:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	PUSHQ %rdi
	PUSHQ %rsi
	SUBQ $40, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ %rbx, -32(%rbp)
	MOVQ $4, %rbx
	MOVQ %rbx, -40(%rbp)
	MOVQ $5, %rbx
	MOVQ %rbx, -48(%rbp)
	MOVQ 24(%rbp), %rbx
	MOVQ 32(%rbp), %r10
	MOVQ -32(%rbp), %r11
	MOVQ -40(%rbp), %r12
	SUBQ %r12, %r11
	ADDQ %r10, %r12
	ADDQ %rbx, %r12
	MOV %r12, %rax
	JMP .D_epilogue
.D_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $40, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $6, %rbx
	MOVQ $7, %r10
	MOVQ %rbx, %rdi
	MOVQ %r10, %rsi
	PUSHQ %r10
	PUSHQ %r11
	CALL D
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ %rbx, -56(%rbp)
	MOVQ $1, %rbx
	MOVQ $2, %r10
	MOVQ %rbx, %rdi
	MOVQ %r10, %rsi
	PUSHQ %r10
	PUSHQ %r11
	CALL C
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOV %rbx, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET



return code: 18


===[good10.bminor Input]===
w: string = "no";

f: function void (s: string) = {
	{
		w: string = "ok";
		print w, "\n";
		w = "bad!\n";
	}
	print s, ' ', w;
	print " ";
	s = "changed\n";
	print s;
}

main:function integer ()= {
	s: string = "good";
	f(s);
	print s;

	return 0;
}

===[good10.bminor Output]===
TEST NOT PASSED - CODEGEN ERROR



return code: 1


===[good14.bminor Input]===
/*
Return pointer to (constant) global
string which is valid to display.
*/

s: string = "ok\n";

f: function string() = {
	t: string = s;
	return t;
}

main: function integer () = {
	print f();
	return 0;
}

===[good14.bminor Output]===
TEST NOT PASSED - RUNTIME ERROR



return code: -11


===[good16.bminor Input]===
// https://piazza.com/class/jziupd2lzpm7cy?cid=176

main: function integer() = {
	print "Testing printing literals", '\n', 123, "abc", true, false, 5;
	return 0;
}


===[good16.bminor Output]===
TEST NOT PASSED - COMPILE ERROR


../hidden-tests/codegen/good16.bminor.s: Assembler messages:
../hidden-tests/codegen/good16.bminor.s:33: Error: invalid character (0x7f) in operand 2

return code: 1


====Bad Tests====
===== SUMMARIZED CODEGEN RESULTS =====
{
  "student_tests": {
    "Good": {
      "correct": 22,
      "incorrect": 0
    },
    "Bad": {
      "correct": 0,
      "incorrect": 0
    }
  },
  "hidden_tests": {
    "Good": {
      "correct": 7,
      "incorrect": 13
    },
    "Bad": {
      "correct": 0,
      "incorrect": 0
    }
  }
}

Codegen Project Grade
-------------------

General Structure: 23/25
---------------------------------
Some issues generating code with arrays, long expressions

Codegen - Functionality 13/15 
--------------------------------------------
One assembled program crashes. another causes an infinite loop
as noted

Codegen - Assembly Structure 10/10 
--------------------------------------------
assembly looks good

Student Tests: 20/20
---------------------------
Passes all your tests.

Hidden Tests: 7/20
---------------------------
Passes 7 hidden tests

Code Style: 10/10
------------------------
Looks good

Extra Credit: 0/10
------------------------

Total: 83/100
------------------------------------------
